<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>线性方程组与本征值问题(05)：原始的 QR 算法</title>
    <link href="/posts/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E4%B8%8E%E6%9C%AC%E5%BE%81%E5%80%BC%E9%97%AE%E9%A2%98(05)%EF%BC%9A%E5%8E%9F%E5%A7%8B%E7%9A%84%20QR%20%E7%AE%97%E6%B3%95/"/>
    <url>/posts/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E4%B8%8E%E6%9C%AC%E5%BE%81%E5%80%BC%E9%97%AE%E9%A2%98(05)%EF%BC%9A%E5%8E%9F%E5%A7%8B%E7%9A%84%20QR%20%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><spanclass="math inline">\(\newcommand{\mb}{\mathbf}\)</span>对于矩阵的谱,有几种求法:</p><ol type="1"><li>解特征多项式</li><li>任何一本线代教材都会讲到的对角化手续</li><li>...</li></ol><p>第一种方法求方程的数值解, 原则上需要迭代; 第二种不一定适用,因为矩阵未必能够对角化.是否可以找到一个求一般矩阵的本征值的"直接解法"呢?</p><p>很不幸的是, 这一点原则上是不可能的.假设存在一个有限步骤的所谓"直接算法",即通过有限多次的初等代数运算就可以获得一般矩阵的本征值,就意味着存在一个任意阶多项式求根的公式, 而这是与 Abel对高次方程的研究相矛盾的.</p><p>因此, 本征值问题的一般解仍需要迭代方法, 本节将要介绍的是著名的 QR算法.</p><h2 id="qr-分解">QR 分解</h2><p>在引入 QR 算法前, 先介绍实矩阵的 QR 分解:</p><blockquote><p>如果矩阵<span class="math inline">\(\mb{A}\in\R^{n\timesn}\)</span>并且满足 <span class="math display">\[\mb{A}=\mb{Q}\mb{R}\]</span> 其中, <span class="math inline">\(\mb{Q}\)</span>和<spanclass="math inline">\(\mb{R}\)</span>分别是正交矩阵和上三角矩阵,则称之为矩阵<span class="math inline">\(\mb{A}\)</span>的一个 <strong>QR分解</strong>.</p></blockquote><h3 id="非奇异矩阵">非奇异矩阵</h3><p>QR 分解的存在性可以利用所谓的 Schmidt 正交归一化来说明. 考虑<spanclass="math inline">\(\mb{A}\)</span>的列向量组<spanclass="math inline">\(\{\pmb{\alpha}_1,\pmb{\alpha}_2,\cdots,\pmb{\alpha}_n\}\)</span>​线性无关,那么有所谓的 <strong>Schmidt 正交归一化手续</strong> 得到一个正交归一基:<span class="math display">\[\begin{flalign*}&amp;\pmb{\gamma}_1 &amp;= \frac{\pmb{\beta}_1}{|\!|\pmb{\beta}_1|\!|}\qquad&amp;\pmb{\beta}_1 = \pmb{\alpha}_1\\&amp;\pmb{\gamma}_2 &amp;= \frac{\pmb{\beta}_2}{|\!|\pmb{\beta}_2|\!|}\qquad&amp;\pmb{\beta}_2 = \pmb{\alpha}_2-(\pmb{\alpha}_2,\pmb{\gamma}_1)\pmb{\gamma}_1\\&amp; &amp; \vdots\\&amp;\pmb{\gamma}_k &amp;= \frac{\pmb{\beta}_k}{|\!|\pmb{\beta}_k|\!|}\qquad&amp;\pmb{\beta}_k = \pmb{\alpha}_k-\sum_{j=1}^{k-1}(\pmb{\alpha}_k, \pmb{\gamma}_j)\pmb{\gamma}_j\\&amp; &amp; \vdots\end{flalign*}\]</span> 其中, <span class="math inline">\(k=1,2,\cdots,n\)</span>,<span class="math inline">\((\sim_1,\sim_2)\)</span>表示向量的内积.如果定义新的矩阵元 <span class="math display">\[r_{jk}=\begin{align*}\begin{cases}\displaystyle(\pmb{\alpha}_k,\pmb{\gamma}_j)\qquad &amp;j&lt;k\\\\\displaystyle|\!|\pmb{\beta}_k|\!| &amp;j=k\\\\\displaystyle0 &amp;j&gt;k\end{cases}\end{align*}\]</span> 则有 <span class="math display">\[\pmb{\alpha}_k=\sum_{j=1}^n\pmb{\gamma}_{j}r_{jk}\qquad\Rightarrow\qquad\begin{pmatrix}\pmb{\alpha}_1&amp;\cdots&amp;\pmb{\alpha}_n\end{pmatrix}=\begin{pmatrix}\pmb{\gamma}_1&amp;\cdots&amp;\pmb{\gamma}_n\end{pmatrix}\begin{pmatrix}r_{11} &amp; r_{12} &amp; \cdots &amp; r_{1n}\\&amp; r_{22} &amp; \cdots &amp; r_{2n}\\&amp;&amp; \ddots &amp; \vdots\\&amp;&amp;&amp; r_{nn}\end{pmatrix}\]</span> 即<span class="math inline">\(\mb{A}=\mb{Q}\mb{R}\)</span>.可见任何非奇异方阵都存在 QR 分解.</p><h3 id="奇异矩阵">奇异矩阵</h3><p>考虑<span class="math inline">\(\mb{A}\in\R^{n\times n}\)</span>,且<span class="math inline">\(\rank(\mb{A})=m\)</span>. 和上面相当类似,对于前<span class="math inline">\(k\)</span>列构成的向量组<spanclass="math inline">\(\{\pmb{\alpha}_1,\cdots,\pmb{\alpha}_k\}\)</span>,设它的秩为<span class="math inline">\(m_k\)</span>, 显然<spanclass="math inline">\(m_1=1\)</span>, <spanclass="math inline">\(m_n=m\)</span>. 可以找到<spanclass="math inline">\(\{\pmb{\varepsilon}_1,\cdots,\pmb{\varepsilon}_{m_k}\}\)</span>这<spanclass="math inline">\(m_k\)</span>个正交归一向量构成的基来线性表示:<span class="math display">\[\pmb{\alpha}_k=\sum_{j=1}^{m_k}(\pmb{\alpha}_k,\pmb{\varepsilon}_j)\pmb{\varepsilon}_j\]</span> 因为<span class="math inline">\(m_k\le k\)</span>, 所以<spanclass="math inline">\((\pmb{\alpha}_k,\pmb{\varepsilon}_j)\)</span>仍是一个上三角矩阵的矩阵元.与非奇异的区别在于, 这里的上三角矩阵即使在上三角部分也会出现零元,甚至必定出现零元. 它的后<spanclass="math inline">\(n-m\)</span>行都是零行. 另外还需注意,<strong>到目前为止, <spanclass="math inline">\(\pmb{\varepsilon}_j\)</span>无法构成正交矩阵</strong>.它只有<span class="math inline">\(m\)</span>个矢量. 我们再找<spanclass="math inline">\(n-m\)</span>个列矢量, 使得所有<spanclass="math inline">\(n\)</span>个构成正交归一基,这样才能形成正交矩阵.</p><p>综上所述, 此时仍存在分解, 只是<spanclass="math inline">\(\mb{Q}\)</span>的前<spanclass="math inline">\(m\)</span>列就足以表示<spanclass="math inline">\(\mb{A}\)</span>, 因而<spanclass="math inline">\(\mb{R}\)</span>也只有前<spanclass="math inline">\(m\)</span>行才可能出现非零元, 后<spanclass="math inline">\(n-m\)</span>行无论对角线上下都是零元.</p><h2 id="标准-qr-迭代">标准 QR 迭代</h2><p>前面已经证明了方阵普遍具备 QR 分解, 现在可以介绍 QR迭代的基本步骤了.</p><h3 id="要求">要求</h3><p>初始矩阵<span class="math inline">\(\mb{A}\)</span>,初始正交矩阵<span class="math inline">\(\mb{Q}^{(0)}\)</span>. 若<spanclass="math inline">\(\mb{Q}^{(0)}=\mb{I}\)</span>, 则<spanclass="math inline">\(\mb{T}^{(0)}=\mb{A}\)</span>.</p><h3 id="步骤">步骤</h3><ol type="1"><li><p><strong>for</strong> <spanclass="math inline">\(k=1,2,\cdots\)</span> <strong>do</strong></p></li><li><ul><li>对矩阵<span class="math inline">\(\mb{T}^{(k-1)}\)</span>进行 QR分解, 即 <span class="math display">\[   \mb{T}^{(k-1)}=\mb{Q}^{(k)}\mb{R}^{(k)}   \]</span></li></ul></li><li><ul><li>计算<spanclass="math inline">\(\mb{T}^{(k)}=\mb{R}^{(k)}\mb{Q}^{(k)}\)</span>.</li></ul></li><li><ul><li>这一步进行终止条件判定.</li></ul></li><li><p>输出结果</p></li></ol><h3 id="复杂度分析">复杂度分析</h3><p><spanclass="math inline">\(n\)</span>阶方阵乘法每确定一个矩阵元为<spanclass="math inline">\(O(n)\)</span>, 共<spanclass="math inline">\(n^2\)</span>个, 因此总复杂度为<spanclass="math inline">\(O(n^3)\)</span>.</p><h2 id="实-schur-分解">实 Schur 分解</h2><p>作为迭代算法, QR 迭代当然是近似的. 它的每一步结果是 <spanclass="math display">\[\mb{T}^{(k)}=\left(\mb{Q}^{(0)}\cdots\mb{Q}^{(k)}\right)^\mb{T}\mb{A}\left(\mb{Q}^{(0)}\cdots\mb{Q}^{(k)}\right)\]</span> 实际上, 如果<spanclass="math inline">\(\mb{A}\)</span>存在复本征值, 那么<spanclass="math inline">\(\mb{T}^{(k)}\)</span>永不可能是真的上三角的.一方面, 实矩阵之积必定是实矩阵, 另一方面, <spanclass="math inline">\(\mb{A}\)</span>相似变换而成的上三角矩阵,对角元都是本征值. 因此,具有复本征值的矩阵不可能在实数域上严格上三角化.</p><p>尽管如此, 我们可以设法让<spanclass="math inline">\(\mb{A}\)</span>"尽量上三角化":</p><blockquote><h5 id="实-schur-形式">实 Schur 形式:</h5><p><span class="math inline">\(\forall\mb{A}\in\R^{n\times n}\)</span>,<span class="math inline">\(\exist\mb{Q}\)</span>为正交矩阵且 <spanclass="math display">\[\mb{Q}^\mb{T}\mb{A}\mb{Q}=\begin{pmatrix}R_{11} &amp; R_{12} &amp; \cdots &amp; R_{1m}\\0 &amp; R_{22} &amp; \cdots &amp; R_{2m}\\\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\0 &amp; 0 &amp; \cdots &amp; R_{mm}\end{pmatrix}\]</span> 其中<span class="math inline">\(R_{ii}\in\R\)</span>或<spanclass="math inline">\(R_{ii}\in\R^{2\times2}\)</span>.这样的形式称作矩阵<span class="math inline">\(\mb{A}\)</span>的<strong>实 Schur 形式</strong>.</p></blockquote><p>不难看出, 实 Schur 形式很可能不是上三角的, 它的对角元处允许<spanclass="math inline">\(2\times2\)</span>的块矩阵存在(其实也只允许对角线下方的副对角线存在),这代表着一对共轭的复本征值<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="我们好像没有说明共轭的根据, 这是因为本征方程是实数, 它取共轭不变, 因此根也是如此.">[1]</span></a></sup>.</p><p>下面的定理给出具体操作:</p><blockquote><p>正交矩阵<span class="math inline">\(\mb{Q}\)</span>可以通过 QR迭代获得, 即 <span class="math display">\[\mb{Q}=\lim_{k\to\infty}\left[\mb{Q}^{(0)}\mb{Q}^{(1)}\cdots\mb{Q}^{(k)}\right]\]</span> 这样得到一个矩阵的迭代序列<spanclass="math inline">\(\{\mb{T}^{(i)}\}\)</span>, 本征值满足<spanclass="math inline">\(|\lambda_1|\ge|\lambda_2|\ge\cdots\ge|\lambda_n|\)</span>.则它的非对角元具有如下收敛速度: <span class="math display">\[\left|t_{ij}^{(k)}\right|\sim\left|\frac{\lambda_i}{\lambda_j}\right|^k,i&gt;j\]</span></p></blockquote><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>我们好像没有说明共轭的根据,这是因为本征方程是实数, 它取共轭不变, 因此根也是如此.<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算物理</category>
      
      <category>线性方程组与本征值问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值计算</tag>
      
      <tag>本征值问题</tag>
      
      <tag>QR 算法</tag>
      
      <tag>QR 分解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性方程组与本征值问题(04)：本征值问题的一般描述</title>
    <link href="/posts/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E4%B8%8E%E6%9C%AC%E5%BE%81%E5%80%BC%E9%97%AE%E9%A2%98(04)%EF%BC%9A%E6%9C%AC%E5%BE%81%E5%80%BC%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%80%E8%88%AC%E6%8F%8F%E8%BF%B0/"/>
    <url>/posts/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E4%B8%8E%E6%9C%AC%E5%BE%81%E5%80%BC%E9%97%AE%E9%A2%98(04)%EF%BC%9A%E6%9C%AC%E5%BE%81%E5%80%BC%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%80%E8%88%AC%E6%8F%8F%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>本节开始研究所谓的本征值问题,让我们首先回忆一下关于本征值问题的一些数学定义和一些重要的结果.</p><h2 id="线代知识再回顾">线代知识再回顾</h2><blockquote><p><strong>本征值问题</strong></p><p><spanclass="math inline">\(\forall\mathbf{A}\in\C^{n×n}\Rightarrow\exist(\pmb{x}\in\C^n\backslash\{\pmb{0}\}\and \lambda\in\C)\ ,\ \text{s.t.}\)</span> <spanclass="math display">\[\mathbf{A}\pmb{x}=\lambda\pmb{x}\]</span> 则称<span class="math inline">\(\lambda\)</span>为<spanclass="math inline">\(\mathbf{A}\)</span>的一个<strong>本征值(eigenvalue)</strong>, <spanclass="math inline">\(\pmb{x}\)</span>为这个本征值对应的<strong>(右)本征矢(eigenvector)</strong>. <spanclass="math inline">\(\mathbf{A}\)</span>的全体本征值构成的集合称为<spanclass="math inline">\(\mathbf{A}\)</span>的<strong>谱(spectrum)</strong>, 记作<spanclass="math inline">\(\sigma(\mathbf{A})\)</span>. <spanclass="math inline">\((\lambda,\pmb{x})\)</span>称作矩阵<spanclass="math inline">\(\mathbf{A}\)</span>的一个<strong>本征对(eigenpair)</strong>.</p></blockquote><p>另一个重要概念是矩阵<span class="math inline">\(\mathbf{A}\)</span>的<strong>谱半径(spectral radius)</strong>: <span class="math display">\[\rho(\mathbf{A}):=\max|\sigma(\mathbf{A})|\]</span> <spanclass="math inline">\(|\cdot|\)</span>表示对集合内所有元素取模构成新集合,显然<spanclass="math inline">\(\rho(\mathbf{A})=\rho(\mathbf{A}^\dagger)\)</span>.</p><p>我们还要引入矩阵的 <strong>模(norm)</strong>.</p><blockquote><p><span class="math display">\[\begin{flalign}&amp; \text{e.g.} &amp;\\&amp; &amp;\qquad|\!|\mathbf{A}|\!|:=\sup_{\pmb{x}\ne\pmb{0}}\frac{|\!|\mathbf{A}\pmb{x}|\!|}{|\!|\pmb{x}|\!|}&amp; &amp;\end{flalign}\]</span></p><p>称作 <strong>(矢量模诱导的)矩阵模(matrix norm)</strong>.通常这里的矢量模取为 Euclid 模, 那么相应的矩阵模称作<strong>2-模(2-norm)</strong>.</p></blockquote><blockquote><p><span class="math display">\[\begin{flalign}&amp; \text{e.g.} &amp;\\&amp; &amp; \qquad|\!|\mathbf{A}|\!|_F:=\sqrt{\sum_{j,k}|a_{jk}|^2}&amp; &amp;\end{flalign}\]</span></p><p>称作 <strong>Frobenius 模(Hilbert-Schmidt 模; F-norm)</strong>.</p></blockquote><p>可以证明</p><ol type="1"><li><p><spanclass="math inline">\(|\!|\mathbf{A}|\!|_2\le|\!|\mathbf{A}|\!|_F\)</span></p></li><li><p><spanclass="math inline">\(|\!|\mathbf{A}|\!|_2=\sqrt{\rho(\mathbf{A}^\dagger\mathbf{A})}\)</span>​</p><p>推论:</p><ol type="1"><li>厄密矩阵满足<spanclass="math inline">\(|\!|\mathbf{A}|\!|_2=\rho(\mathbf{A})\)</span></li><li>酉矩阵满足<spanclass="math inline">\(|\!|\mathbf{A}|\!|_2=1\)</span>​</li></ol></li><li><p>两种模都允许 <spanclass="math inline">\(\mathbf{A}\)</span>乘上(无论左右)一个酉矩阵的因子而不改变矩阵模.</p><p>推论:</p><ol type="1"><li>相似变换不改变这两种矩阵模.</li></ol></li></ol><p>对于矩阵的数值计算, <strong>条件数(condition number)</strong>是非常重要的: <span class="math display">\[\kappa(\mathbf{A}):=|\!|\mathbf{A}|\!|\cdot|\!|\mathbf{A}^{-1}|\!|\]</span> 这是非奇异矩阵的定义. 对于奇异矩阵, 约定为<spanclass="math inline">\(+\infty\)</span>.</p><h2 id="矩阵的本征结构与对角化">矩阵的本征结构与对角化</h2><p>先回忆一下相似变换的知识:</p><blockquote><p><strong>相似变换(similar transformation)</strong> 是一个线性变换<spanclass="math inline">\(S_n:\C^{n\times n}\rightarrow \C^{n\timesn}\)</span>, 形如 <span class="math display">\[S_n(\mathbf{A})=\mathbf{C}^{-1}\mathbf{A}\mathbf{C}\]</span> 其中<span class="math inline">\(\mathbf{C}\in\C^{n\timesn}\)</span>且满秩.</p></blockquote><p>显然, 相似变换不改变矩阵的谱, 而(右)本征矢会左乘一个矩阵<spanclass="math inline">\(\mathbf{C}^{-1}\)</span>. 即本征对: <spanclass="math display">\[(\lambda,\pmb{x})\rightarrow(\lambda,\mathbf{C}^{-1}\pmb{x})\]</span> 更特别的, 如果<spanclass="math inline">\(\mathbf{C}\)</span>​是一个酉矩阵(实正交矩阵),则变换称作 <strong>幺正相似变换</strong>(实数域称为<strong>正交变换</strong>).</p><h3 id="schur-分解定理">Schur 分解定理</h3><p>实数域上的代数告诉我们, 不是任意实方阵都能对角化, 推广这一结论,任意复方阵也未必能对角化. 但我们可以退而求其次:</p><blockquote><p><strong>Schur 分解定理</strong></p><p><span class="math inline">\(\forall\mathbf{A}\in\C^{n\times n}\ ,\\exist\mathbf{U}\ \text{s.t.}\)</span>​ <span class="math display">\[\mathbf{U}^{-1}\mathbf{A}\mathbf{U}\equiv\mathbf{U}^\dagger\mathbf{A}\mathbf{U}=\begin{pmatrix}\lambda_1 &amp; \tilde{a}_{12} &amp; \cdots &amp; \tilde{a}_{1n}\\&amp; \lambda_2 &amp; \cdots &amp; \tilde{a}_{2n}\\&amp; &amp; \ddots &amp; \vdots\\&amp; &amp; &amp; \lambda_n\end{pmatrix}\]</span></p></blockquote><p>同样采用归纳法证明, 对于一阶矩阵, 显然成立. 下面证明,如果定理对于<span class="math inline">\(n-1\)</span>阶矩阵成立,那么对<span class="math inline">\(n\)</span>阶矩阵成立.</p><p>为证明之, 考虑<span class="math inline">\(n\)</span>阶矩阵<spanclass="math inline">\(\mathbf{A}\)</span>, 它可以进行分块 <spanclass="math display">\[\mathbf{A}=\begin{pmatrix}a_{11} &amp; \pmb{v}\\\pmb{u}^\dagger &amp; A_{n-1}\end{pmatrix}\]</span> 它具备一系列本征值,挑选一个非零本征值<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="不必考虑本征值全为零的矩阵, 因为零矩阵情形是平庸的; 也不用考虑简并, 后面的证明不需要非简并假设.">[1]</span></a></sup>记作<spanclass="math inline">\(\lambda_1\)</span>,对应地一个归一化的本征矢为<spanclass="math inline">\(\pmb{x}_1\)</span>: <span class="math display">\[\mathbf{A}\pmb{x}_n=\lambda_n\pmb{x}_n\]</span> 从<span class="math inline">\(\C^n\)</span>上不难挑选<spanclass="math inline">\(n-1\)</span>个正交归一的本征矢<spanclass="math inline">\(\{\pmb{x}_2,\cdots,\pmb{x}_n\}\)</span>,并且它们都与<span class="math inline">\(\pmb{x}_1\)</span>​正交.构建相应的酉矩阵 <span class="math display">\[\mathbf{X}=\begin{pmatrix}\pmb{x}_1 &amp; \cdots &amp; \pmb{x}_n\end{pmatrix}\]</span> 以它为参量的相似变换结果为 <span class="math display">\[a^\mathbf{X}_{jk}=[\mathbf{X}^{-1}\mathbf{A}\mathbf{X}]_{jk}=\pmb{x}_j^\dagger\mathbf{A}\pmb{x}_k\]</span> 若<span class="math inline">\(k=1\)</span>, 则<spanclass="math inline">\(a_{jk}^\mathbf{X}=\pmb{x}_j^\dagger\lambda_1\pmb{x}_1=\lambda_1\delta_{j1}\)</span>.可见 <span class="math display">\[\mathbf{X}^{-1}\mathbf{A}\mathbf{X}=\begin{pmatrix}\lambda_1 &amp; \pmb{v}^\mathbf{X}\\\pmb{0} &amp; A_{n-1}^{\mathbf{X}}\end{pmatrix}\]</span> 其实接下来也可以继续递推, 设法将<spanclass="math inline">\(\mathbf{A}_{n-1}^\mathbf{X}\)</span>逐层地上三角化<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="这种证明方法能更直观地体现出上三角化方案不唯一, 对于同一个原始矩阵, 至少可以调整结果中本征值的顺序.">[2]</span></a></sup>,但一系列递推变换的总效果就是<span class="math inline">\(n-1\)</span>阶的Schur 分解定理. 因此还是按照 Schur 分解定理在<spanclass="math inline">\(n-1\)</span>阶上成立的前提进行证明.</p><p>设<spanclass="math inline">\(\mathbf{A}_{n-1}^\mathbf{X}\)</span>上三角化所需的酉矩阵是<spanclass="math inline">\(\mathbf{P}_{n-1}\)</span>, 考虑分块矩阵 <spanclass="math display">\[\mathbf{P}=\begin{pmatrix}1 &amp; \pmb{0}^\dagger\\\pmb{0} &amp; \mathbf{P}_{n-1}\end{pmatrix}\]</span> 则 <span class="math display">\[\mathbf{P}^{-1}\mathbf{X}^{-1}\mathbf{A}\mathbf{X}\mathbf{P}=\begin{pmatrix}\lambda_1 &amp; \mathbf{P}^\dagger\pmb{v}^\mathbf{X}\\\pmb{0} &amp; \mathbf{P}^\dagger A_{n-1}^{\mathbf{X}}\mathbf{P}\end{pmatrix}\]</span> 对角块都是上三角的, 对角线以下是零块,因此整体是一个上三角矩阵, 且对角元都是本征值. <spanclass="math inline">\(\mathbf{X}\mathbf{P}\)</span>​整体承担变换矩阵的作用,并且酉矩阵之积仍是酉的. 得证.</p><h3 id="推论">推论</h3><p>根据 Schur 分解定理, 立即得到:</p><ol type="1"><li><p>厄密矩阵必定可以用酉矩阵对角化, 对角元都是本征值,并且都是实数.</p><p>这可以看作实对称矩阵对角化定理的推广.</p></li><li><p>实矩阵当然也能上三角化, 但对角元未必是实数.有的问题要求把数域限制为<span class="math inline">\(\R\)</span>​,那么实际上无法分解为上三角矩阵.</p><p>这就要引出后面的实 Schur 分解.</p></li></ol><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>不必考虑本征值全为零的矩阵,因为零矩阵情形是平庸的; 也不用考虑简并, 后面的证明不需要非简并假设.<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>这种证明方法能更直观地体现出上三角化方案不唯一,对于同一个原始矩阵, 至少可以调整结果中本征值的顺序.<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算物理</category>
      
      <category>线性方程组与本征值问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值计算</tag>
      
      <tag>本征值问题</tag>
      
      <tag>相似变换</tag>
      
      <tag>对角化</tag>
      
      <tag>Schur 形式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性方程组与本征值问题(03)：三对角矩阵</title>
    <link href="/posts/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E4%B8%8E%E6%9C%AC%E5%BE%81%E5%80%BC%E9%97%AE%E9%A2%98(03)%EF%BC%9A%E4%B8%89%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5/"/>
    <url>/posts/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E4%B8%8E%E6%9C%AC%E5%BE%81%E5%80%BC%E9%97%AE%E9%A2%98(03)%EF%BC%9A%E4%B8%89%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<span class="math inline">\(\newcommand{\mb}{\mathbf}\)</span>所谓<strong>三对角矩阵</strong>, 是指形如 <span class="math display">\[\mathbf{A}=\begin{pmatrix}a_1 &amp; c_1\\b_2 &amp; a_2 &amp; c_2\\&amp; \ddots &amp; \ddots &amp; \ddots\\&amp; &amp; b_{n-1} &amp; a_{n-1} &amp; c_{n-1}\\&amp; &amp; &amp; b_n &amp; a_n\end{pmatrix}\]</span> 的矩阵<span class="math inline">\(\mathbf{A}\)</span>.它同样可以进行 LU 分解, 但分解后的矩阵比较特殊: $$<span class="math display">\[\begin{aligned}\mathbf{L}&amp;=\begin{pmatrix}1 &amp;\\\beta_2 &amp; 1\\&amp; \ddots &amp; \ddots\\&amp; &amp; \beta_n &amp; 1\end{pmatrix}\\\mathbf{U}&amp;=\begin{pmatrix}\alpha_1 &amp; c_1\\&amp; \ddots &amp; \ddots\\&amp; &amp; \alpha_{n-1} &amp; c_{n-1}\\&amp; &amp; &amp; \alpha_n\end{pmatrix}\end{aligned}\]</span><p><span class="math display">\[即\]</span> l_{jj}=1 , l_{j,j-1}=<em>j \ u</em>{jj}=<em>j,u</em>{j,j+1}=c_j <span class="math display">\[从而\]</span>a_{jk}=<em>{m=1}^nl</em>{jm}u_{mk}=(<em>j+<em>jc</em>{j-1})</em>{jk}+c_j<em>{j,k-1}+</em>{j-1}<em>j</em>{j,k + 1} <span class="math display">\[即\]</span> _1 = a_1 \ _j= \ _j=a_j-<em>jc</em>{j-1} \(j=1,2,,n) $$这就是三对角矩阵的 <strong>Thomas 算法</strong>. 它的计算量约为<spanclass="math inline">\(8n-7\)</span>, 分解本身为<spanclass="math inline">\(3n-3\)</span>, 如果还需解线性方程组, 还要多<spanclass="math inline">\(5n-4\)</span>.</p>]]></content>
    
    
    <categories>
      
      <category>计算物理</category>
      
      <category>线性方程组与本征值问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值计算</tag>
      
      <tag>线性方程组</tag>
      
      <tag>三对角矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性方程组与本征值问题(02)：Cholesky 分解</title>
    <link href="/posts/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E4%B8%8E%E6%9C%AC%E5%BE%81%E5%80%BC%E9%97%AE%E9%A2%98(02)%EF%BC%9ACholesky%20%E5%88%86%E8%A7%A3/"/>
    <url>/posts/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E4%B8%8E%E6%9C%AC%E5%BE%81%E5%80%BC%E9%97%AE%E9%A2%98(02)%EF%BC%9ACholesky%20%E5%88%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>Cholesky 分解基于这样一个事实: 对于一个正定厄密矩阵<spanclass="math inline">\(\mathbf{A}\in M_n(\C)\)</span>,可以找到一个矩阵<span class="math inline">\(\mathbf{H}\)</span>使得<spanclass="math inline">\(\mathbf{A}=\mathbf{H}^\dagger\mathbf{H}\)</span>.事实上, 可以要求<spanclass="math inline">\(\mathbf{H}\)</span>是一个上三角矩阵,则这个分解称为 <strong>Cholesky 分解</strong>. Cholesky分解同样把复杂的线性方程组转化为两个较简单的方程组: <spanclass="math display">\[\mathbf{A}\pmb{x}=\pmb{b}\Rightarrow\begin{cases}\displaystyle\mathbf{H}^\dagger\pmb{y} = \pmb{b}\\\\\displaystyle\mathbf{H}\pmb{x}=\pmb{y}\end{cases}\]</span> 一个显而易见的引理是,<strong>正定厄密矩阵的主子矩阵仍是正定厄密的</strong>.这可以直接在如下求和式中 <span class="math display">\[\sum_{j=1}^n\sum_{k=1}^na_{jk}x_jx_k\]</span> 将<spanclass="math inline">\(j,k=m+1,m+2,\cdots,n\)</span>的<spanclass="math inline">\(x_j,x_k\)</span>取作<spanclass="math inline">\(0\)</span>, 不应影响正定二次型的结论,从而得证.</p><p>有了这个引理, 对 Cholesky 分解的研究仍可以按照归纳法的思路进行.假设主子矩阵<span class="math inline">\(\mathbf{A}_{m}\)</span>存在分解矩阵<span class="math inline">\(\mathbf{H}_m\)</span>,更高阶的主子矩阵可以进行分块 <span class="math display">\[\mathbf{A}_{m+1}=\begin{pmatrix}\mathbf{A}_m &amp; \pmb{v}\\\pmb{v}^\dagger &amp; \lambda\end{pmatrix}\]</span> 我们希望它仍存在分解矩阵<spanclass="math inline">\(\mathbf{H}_{m+1}\)</span>, 同样可以分块为 <spanclass="math display">\[\mathbf{H}_{m+1}=\begin{pmatrix}\mathbf{H}_m &amp; \pmb{u}\\\pmb{0}^\dagger &amp; \mu\end{pmatrix}\\\mathbf{H}_{m+1}^\dagger=\begin{pmatrix}\mathbf{H}_m^\dagger &amp; \pmb{0}\\\pmb{u}^\dagger &amp; \mu\end{pmatrix}\]</span> 则有 <span class="math display">\[\mathbf{H}_m^\dagger\pmb{u}=\pmb{v}\\\pmb{u}^\dagger\pmb{u}+\mu^2=\lambda\]</span> 设<spanclass="math inline">\(\mathbf{H}^\dagger\)</span>的<spanclass="math inline">\((j,k)\)</span>元为<spanclass="math inline">\(h_{jk}\)</span>, 则 <span class="math display">\[\sum_{l=1}^{k}h_{jl}h_{kl}^\dagger=a_{jk}\\(k=1,2,\cdots,j)\]</span> 写成<span class="math inline">\(h_{jk}\)</span>的显式 <spanclass="math display">\[h_{jk}=\frac{\displaystylea_{jk}-\sum_{l=1}^{k-1}h_{jl}h^\dagger_{kl}}{h^\dagger_{kk}}\\(k=1,2,\cdots,j-1)\\h_{jj}=\sqrt{a_{jj}-\sum_{l=1}^{j-1}|h_{jl}|^2}\]</span></p><h3 id="算法总结">算法总结</h3><p>如下为算法流程:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <span class="hljs-comment"># 仅作为示意, 指标起点取0</span><br>h[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] = np.sqrt(a[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>])<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(j):<br>        h[j,k]=(a[j, k]-h[j, :k]@np.conj(h[k, :k])) / h[j, j]<br>       <br>    h[j, j] = np.sqrt(a[j, j] - np.<span class="hljs-built_in">sum</span>(np.<span class="hljs-built_in">abs</span>(h[j, :j]) ** <span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p>Cholesky 分解的计算量约为<spanclass="math inline">\(\displaystyle\frac{n^3}{3}\)</span>, 比 LU分解通常少一半. 它的特殊形式为正定实对称矩阵的分解, 这种矩阵相当常见,比如协方差矩阵.</p>]]></content>
    
    
    <categories>
      
      <category>计算物理</category>
      
      <category>线性方程组与本征值问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值计算</tag>
      
      <tag>线性方程组</tag>
      
      <tag>厄密矩阵</tag>
      
      <tag>三角矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/posts/img/"/>
    <url>/posts/img/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Fourier 方法(02)：FFT 及其 python 实现</title>
    <link href="/posts/Fourier%20%E6%96%B9%E6%B3%95(02)%EF%BC%9AFFT%20%E5%8F%8A%E5%85%B6%20python%20%E5%AE%9E%E7%8E%B0/"/>
    <url>/posts/Fourier%20%E6%96%B9%E6%B3%95(02)%EF%BC%9AFFT%20%E5%8F%8A%E5%85%B6%20python%20%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>本节介绍基于 DTFT 的算法——快速 Fourier 变换, 以及用于实现这一算法的python 模块.</p><h2 id="快速-fourier-变换fft">快速 Fourier 变换(FFT)</h2><p>FFT 的基本原理其实很简单, 基本上就是 <strong>分而治之 (divide andconquer, D&amp;C)</strong> 的方法. 为了方便, 将相因子记为 <spanclass="math display">\[\phi_N:=\exp{(\frac{2\pi i}{N})}\]</span> 那么规模为<span class="math inline">\(2N\)</span>的 DTFT可以写为 <span class="math display">\[G_m=\frac{1}{2N}\sum_{n=0}^{2N-1}\phi_{2N}^{mn}g_n\]</span> 将它按照奇数项和偶数项拆开: <span class="math display">\[\begin{aligned}G_m&amp;=\frac{1}{2N}\sum_{j=0}^{N-1}\phi_{2N}^{2mj}g_{2j}+\frac{1}{2N}\sum_{k=0}^{N-1}\phi_{2N}^{m(2k+1)}g_{2k+1}\\&amp;=\frac{1}{2N}\sum_{j=0}^{N-1}\phi_{N}^{mj}g_{2j}+\frac{1}{2N}\sum_{k=0}^{N-1}\phi_{N}^{mk}g_{2k+1}\exp{(\frac{i\pim}{N})}\end{aligned}\]</span> 这就是著名的 <strong>Danielson-Lanczos 引理</strong>,类似于著名的归并排序算法, 它实际上给出两个规模为<spanclass="math inline">\(N\)</span>​的 DTFT, 可以不断向下递归,每次二分时域样本集, 直到集合很小以至于极其好算, 这样就把<spanclass="math inline">\(O(N^2)\)</span>的问题转化为了<spanclass="math inline">\(O(N\log N)\)</span>的问题.</p><h2 id="numpy.fft模块简介"><code>numpy.fft</code>模块简介</h2><p>著名的科学计算工具<code>numpy</code>有一套成熟的函数模块用于计算 FFT.当然, 它与常使用的公式略有区别. 上节提到,数学上喜欢将因子全部放在变换公式中, 让反变换不带有系数, 即 <spanclass="math display">\[\begin{aligned}G_m&amp;=\frac{1}{N}\sum_{n=0}^{N-1}g_n\exp{(-\frac{2\pi imn}{N})}\\g_n&amp;=\sum_{m}G_m\exp{(\frac{2\pi imn}{N})}\end{aligned}\]</span> 这样的<spanclass="math inline">\(G_m\)</span>正是按照复指数函数分解后的系数,更具有"频谱"的意义. 如果<spanclass="math inline">\(g_n\)</span>就是<spanclass="math inline">\(x_0+\displaystyle\frac{n}{f_s}\)</span>处的函数值,那么<span class="math inline">\(G_m\)</span>代表着空间频率为<spanclass="math inline">\(k=\displaystyle\frac{mf_s}{N}\)</span>的分量的复振幅(这里其实还相差一个相因子<spanclass="math inline">\(\exp({2\pi ikx_{center}})\)</span>, 其中<spanclass="math inline">\(x_{center}\)</span>是空时域采样位置的中位数),科学计算工具未必采用这种约定, 因此编写代码时反复乘除<spanclass="math inline">\(N\)</span>因子并不是值得惊奇的事情.</p><p>上述式子中, 我们没有指定<spanclass="math inline">\(m\)</span>​的求和范围,是打算说明空间频率的选取具有一定的任意性.</p><h3 id="空间频率的选取-采样定理">空间频率的选取, 采样定理</h3><p>按照复指数函数的周期性, 很容易看出 <span class="math display">\[G_{m\pm N}=G_m\]</span> 因此, 所谓的空间频率为<spanclass="math inline">\(\displaystyle0,\frac{f_s}{N},\frac{2f_s}{N},\cdots,\frac{N-1}{N}f_s\)</span>和<spanclass="math inline">\(\displaystyle-f_s,-\frac{N-1}{N}f_s,-\frac{N-2}{N}f_s,\cdots,-\frac{f_s}{N}\)</span>是等价的.从这个无限序列中, 任选<spanclass="math inline">\(N\)</span>个在不同等价类中的空间频率,都能根据反变换复原出全套的<span class="math inline">\(g_n\)</span>.如果我们执意从<spanclass="math inline">\(0\)</span>频率出发向两侧选取频率,那么频率绝对值中最大的也不会超出<spanclass="math inline">\(\displaystyle\frac{f_s}{2}\)</span>​, 这就是著名的<strong>采样定理</strong>.</p><h3 id="正反变换">正/反变换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">numpy.fft.fft(a, n=<span class="hljs-literal">None</span>, axis=-<span class="hljs-number">1</span>, norm=<span class="hljs-string">&quot;backward&quot;</span>)<br>numpy.fft.ifft(a, n=<span class="hljs-literal">None</span>, axis=-<span class="hljs-number">1</span>, norm=<span class="hljs-string">&quot;backward&quot;</span>)<br></code></pre></td></tr></table></figure><p>它们是最基本的 FFT 函数, 其中</p><ul><li><code>a: numpy.ndarray</code>表示变换/反变换的对象,<ul><li>它可能是一个多维数组, <code>axis</code>指定变换所处的维度,默认取<code>-1</code>即最后一维.</li></ul></li><li><code>n: int</code>指定样本长度,输入<code>None</code>表示根据<code>a</code>的长度来决定. 如果输入具体值,长则切片, 短则用<code>0</code>补齐.</li><li><code>norm: str</code>表示归一化,<code>"forward"/"backward"</code>分别指定对变换/反变换得到的矢量归一化,<code>"ortho"</code>则会将<spanclass="math inline">\(N\)</span>因子均分给正/反变换.</li></ul><p>如果不打算对后三个 params 多加干涉, 那么以下两点需要重点注意:</p><ol type="1"><li><p>如果输入的<code>g</code>正好是空时域采样,则<code>numpy.fft.fft(g)</code>给出的是<spanclass="math inline">\(N\cdot G\)</span>,因为默认的归一化方式是<code>backward</code>, 它会把<spanclass="math inline">\(N\)</span>因子全部放到反变换里; 同样地,如果输入的<code>G</code>是特定频率的复振幅,则<code>numpy.fft.ifft(G)</code>输出的是<spanclass="math inline">\(\displaystyle\frac{g}{N}\)</span>;将两个函数复合显然仍能够回到数组自身.</p></li><li><p>令<code>G = numpy.fft.fft(g) / len(g)</code>,则<code>G[m]</code>未必代表<spanclass="math inline">\(\displaystyle\frac{mf_s}{N}\)</span>对应的复振幅,这是由于返回的数组采用相当奇葩的方式. 给定正指标<code>m</code>,如果<code>m &lt;= (N - 1) // 2</code>,那么<code>G[m]</code>的确具有这种含义; 否则,<code>G[m]</code>实际上对应着<spanclass="math inline">\(\displaystyle\frac{(m-N)f_s}{N}\)</span>.频率序列详解请看下一部分.</p></li></ol><h3 id="频率序列">频率序列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">numpy.fft.fftfreq(n, d=<span class="hljs-number">1.0</span>)<br></code></pre></td></tr></table></figure><p>这是<code>numpy.fft.fft</code>对应的频率序列.</p><ul><li><p><code>n</code>仍表示样本长度, 这时必须准确地指定.</p></li><li><p><code>d</code>是采样间隔, 即<spanclass="math inline">\(\displaystyle\frac{1}{f_s}\)</span>, 因此<spanclass="math inline">\(\displaystyle\frac{mf_s}{n}\)</span>​​即是<code>m / (n * d)</code>.</p></li></ul><p>频率序列的具体形式见如下代码与注释.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">d = <span class="hljs-number">1</span> / fs<br>freqs = numpy.fft.fftfreq(N, d)<br><span class="hljs-comment"># N = 2 * k: freqs = [0, 1, ..., k - 1, - k, - k + 1, ..., -1] / (N * d)</span><br><span class="hljs-comment"># N = 2 * k + 1: freqs = [0, 1, ..., k,  - k, - k + 1, ..., -1] / (N * d)</span><br></code></pre></td></tr></table></figure><p>即大约前一半是零频率以及递增的正频率,大约后一半是递增的负频率(绝对值递减), 如果<code>N</code>是偶数,负频率项要比正频率项多一项.</p><p>有时候, 将序列按照频率从负到正从小到大顺次重排是更有必要的,这有赖于所谓的 shift 函数.</p><h3 id="shift-函数">shift 函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">numpy.fft.fftshift(x, axes=<span class="hljs-literal">None</span>)<br>numpy.fft.ifftshift(x, axes=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p><code>fftshift</code>是能够重排频谱的函数,<code>ifftshift</code>不是<code>ifft</code>的 shift 函数,而是<code>fftshift</code>的反函数. 下面以前者为例说明参数:</p><ul><li><code>x</code>输入一个数组,最好是<code>numpy.fft.fftshift</code>返回的结果</li><li><code>axes: int | tuple</code>规定作用轴,默认<code>None</code>表示每根轴都作用</li></ul><p><code>fftshift</code>将<span class="math inline">\(\{0, 1, ..., k -1(,- k),- k + 1, ..., -1\}\)</span>重排为<span class="math inline">\(\{-k + 1, ..., -1,0, 1, ..., k - 1(,- k)\}\)</span>,而<code>ifftshift</code>正相反.</p>]]></content>
    
    
    <categories>
      
      <category>计算物理</category>
      
      <category>Fourier 方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值计算</tag>
      
      <tag>Fourier 分析</tag>
      
      <tag>FFT</tag>
      
      <tag>python</tag>
      
      <tag>numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fourier 方法(01)：从连续到离散</title>
    <link href="/posts/Fourier%20%E6%96%B9%E6%B3%95(01)%EF%BC%9A%E4%BB%8E%E8%BF%9E%E7%BB%AD%E5%88%B0%E7%A6%BB%E6%95%A3/"/>
    <url>/posts/Fourier%20%E6%96%B9%E6%B3%95(01)%EF%BC%9A%E4%BB%8E%E8%BF%9E%E7%BB%AD%E5%88%B0%E7%A6%BB%E6%95%A3/</url>
    
    <content type="html"><![CDATA[<p>考虑函数<span class="math inline">\(g(x)\)</span>​的 Fourier变换以及逆变换 <span class="math display">\[G(k)=\int_{-\infty}^{+\infty}g(x)e^{-2\pi ikx}dx\\g(x)=\int_{-\infty}^{+\infty}G(k)e^{2\pi ikx}dk\]</span> 数值计算中, 很多时候连续函数也是用离散的形式表达的,积分不是针对一个解析式进行符号计算,而是输入一个有限规模的样本来近似替代积分, 例如 <spanclass="math display">\[\{g(x_0+\frac{n}{f_s})|n\in\mathbb{N}\ ,n&lt;N\}\]</span> 因此我们实际计算的并不是<spanclass="math inline">\(g(x)\)</span>本身的变换, 而是如下分段函数的变换<span class="math display">\[\bar{g}(x)=\begin{aligned}\begin{cases}0\qquad &amp; x\in(-\infty,x_0)\\g(x_0)\qquad &amp;\displaystyle x\in[x_0,x_0+\frac{1}{f_s})\\\displaystyleg(x_0+\frac{1}{f_s})\qquad &amp;\displaystyle x\in[x_0+\frac{1}{f_s},x_0+\frac{2}{f_s})\\\vdots\\\displaystyleg(x_0+\frac{N-1}{f_s})\qquad &amp;\displaystylex\in[x_0+\frac{N-1}{f_s}, x_0+\frac{N}{f_s}]\\0\qquad &amp;\displaystyle x\in(x_0+\frac{N}{f_s},+\infty)\end{cases}\end{aligned}\]</span> 相应的频谱为 <span class="math display">\[\bar{G}(k)=\frac{1-\exp{(\displaystyle-\frac{2\pi ik}{f_s})}}{2\piik}e^{-2\pi ikx_0}\sum_{n=0}^{N-1} g(x_0+\frac{n}{f_s})e^{-\frac{2\pi ikn}{f_s}}\]</span> 如果我们将<spanclass="math inline">\(g(x_0+\displaystyle\frac{n}{f_s})\)</span>简记为<spanclass="math inline">\(g_n\)</span>, 同时<spanclass="math inline">\(k\)</span>也不取连续变量, 令 <spanclass="math display">\[k=\frac{mf_s}{N}\ ,\ m=0,1,\cdots,N-1\\G_m:=\frac{2\pi ike^{2\pi ikx_0}\bar{G}(k)}{1-\exp{(\displaystyle-\frac{2\piik}{f_s})}}\Bigg|_{k=\frac{mf_s}{N}}\]</span> 也就给出 <span class="math display">\[G_m=\sum_{n=0}^{N-1}g_ne^{-\frac{2\pi imn}{N}}\]</span> 这就是所谓的 <strong>时域离散 Fourier 变换(DTFT)</strong>,它的反变换如何? 可以猜测为 <span class="math display">\[\mathcal{F}^{-1}[G]_n=\sum_{m=0}^{N-1}G_me^{\frac{2\piimn}{N}}=\sum_{m,n&#39;}g_{n&#39;}\exp{(\frac{2\pi im(n-n&#39;)}{N})}\]</span> 幸好时域样本<spanclass="math inline">\(g_{n&#39;}\)</span>不依赖于<spanclass="math inline">\(m\)</span>, 可以按照等比序列的方法对<spanclass="math inline">\(m\)</span>求和, 即 <span class="math display">\[\mathcal{F}^{-1}[G]_n=\sum_{n&#39;=0}^{N-1}g_{n&#39;}\frac{1-e^{iN\phi}}{1-e^{i\phi}}\,\ \phi=\frac{2\pi(n-n&#39;)}{N}\]</span> 显然, <span class="math inline">\(N\phi\)</span>总是导向<spanclass="math inline">\(2\pi\)</span>的整数倍, 因此分子总是<spanclass="math inline">\(0\)</span>, 只要分数不构成<spanclass="math inline">\(\displaystyle\frac{0}{0}\)</span>型未定式,就给出零结果, 又<span class="math inline">\(|n-n&#39;|\le N-1\)</span>,因此当且仅当<span class="math inline">\(n&#39;=n\)</span>时构成未定式,<span class="math inline">\(n&#39;\ne n\)</span>时都给出零结果.</p><p>现在只需要关注<span class="math inline">\(n&#39;=n\)</span>项,退回计算等比序列和之前, 立即得到 <span class="math display">\[\mathcal{F}^{-1}[G]_n=\sum_{m=0}^{N-1}g_n=Ng_n\]</span> 我们最终得到完整的变换-反变换式: <span class="math display">\[\begin{aligned}G_m&amp;=\sum_{n=0}^{N-1}g_n\exp{(-\frac{2\pi imn}{N})}\\g_n&amp;=\frac{1}{N}\sum_{m=0}^{N-1}G_m\exp{(\frac{2\pi imn}{N})}\end{aligned}\]</span> <span class="math inline">\(N\)</span>因子依然可以随意分配,也就是说可以改写为 <span class="math display">\[\begin{aligned}G_m&amp;=\frac{1}{N}\sum_{n=0}^{N-1}g_n\exp{(-\frac{2\pi imn}{N})}\\g_n&amp;=\sum_{m=0}^{N-1}G_m\exp{(\frac{2\pi imn}{N})}\end{aligned}\]</span> 这样写的好处是, 数学上使用反变换更多, 或者说将信号 Fourier分解为频域上的谱, 频谱前面最好不带有系数,但是前一种写法在程序中也不少见.</p><p>像这样计算一次完整的变换或反变换, 需要对<spanclass="math inline">\(m\)</span>和<spanclass="math inline">\(n\)</span>二重循环, 给出<spanclass="math inline">\(O(N^2)\)</span>的时间复杂度. 下面将要介绍的<strong>快速 Fourier 变换(FFT)</strong> 是一种可以简化至<spanclass="math inline">\(O(N\log N)\)</span>​的算法.</p>]]></content>
    
    
    <categories>
      
      <category>计算物理</category>
      
      <category>Fourier 方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值计算</tag>
      
      <tag>Fourier 分析</tag>
      
      <tag>DTFT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数值解和优化问题(04)：基于梯度的多元函数优化</title>
    <link href="/posts/%E6%95%B0%E5%80%BC%E8%A7%A3%E5%92%8C%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98(04)%EF%BC%9A%E5%9F%BA%E4%BA%8E%E6%A2%AF%E5%BA%A6%E7%9A%84%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E4%BC%98%E5%8C%96/"/>
    <url>/posts/%E6%95%B0%E5%80%BC%E8%A7%A3%E5%92%8C%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98(04)%EF%BC%9A%E5%9F%BA%E4%BA%8E%E6%A2%AF%E5%BA%A6%E7%9A%84%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>上一节绕过求导数直接对函数优化, 可以看到还是比较复杂的,而本节打算从最理想的二次型出发, 基于函数的导函数来研究优化问题,因为二次型的形式比较简单: <span class="math display">\[f_{p}(\boldsymbol{x})=f_p(\boldsymbol{x}_0)-\boldsymbol{b}^{\mathbf{T}}\cdot(\boldsymbol{x}-\boldsymbol{x}_0)+\frac{1}{2}(\boldsymbol{x}-\boldsymbol{x}_0)^{\mathbf{T}}\mathbf{A}(\boldsymbol{x}-\boldsymbol{x}_0)\]</span> 即二次型是一种一二阶导都是常量且高阶导数为零的同时,还可优化的函数. 不失一般性, 对于函数<span class="math inline">\(f\in\mathbb{C}^{2}\)</span>, 平移初始位置和函数值的零点, 使得它总能写成形如<span class="math display">\[f(\boldsymbol{x})=-\boldsymbol{b}^\mathbf{T}\cdot\boldsymbol{x}+\frac{1}{2}\boldsymbol{x}^\mathbf{T}\mathbf{A}\boldsymbol{x}+o(|\boldsymbol{x}|^2)\]</span> 的形式. <spanclass="math inline">\(\boldsymbol{b}\)</span>和<spanclass="math inline">\(\mathbf{A}\)</span>分别给定<spanclass="math inline">\(f(\boldsymbol{x})\)</span>在原点的一阶和二阶偏导数.还可以定义 <strong>残差</strong>: <span class="math display">\[\begin{aligned}\boldsymbol{r}(\boldsymbol{x}) &amp;= -\boldsymbol{\nabla}f(\boldsymbol{x})\\\text{对于上述平移}&amp;\text{过的函数式, 有}\\\boldsymbol{r}(\boldsymbol{x}) &amp;\approx\boldsymbol{b}-\mathbf{A}\boldsymbol{x}\end{aligned}\]</span> 现在我们从原点出发, 希望对函数进行优化.</p><h2 id="最速下降法">最速下降法</h2><p>最速下降法的逻辑十分简单:在一个点附近最好的局部优化方向自然是负梯度方向, 即残差方向: <spanclass="math display">\[\boldsymbol{x}_{k+1}=\boldsymbol{x}_k+\lambda_k\boldsymbol{r}_k\]</span> 其中<spanclass="math inline">\(\lambda_k\)</span>是个待定参数,它自身构成一维优化问题, 因为: <span class="math display">\[\phi_k(\lambda_k):=f(\boldsymbol{x}_k+\lambda_k\boldsymbol{r}_k)\]</span> 像这样反复迭代, 最终加上一定的结束条件即可.</p><h2 id="共轭梯度法">共轭梯度法</h2><p>上面的最速下降法类似一种贪心策略, 通过一系列局部最优达到整体的最优,但是很多时候, 局部最优并不导向整体最优,或者处处进行局部优化并不是很高效的方案.如果函数的二阶导数在某些方向比较奇葩,例如相较于其他方向而言具有特别大的数值,在这样复杂的地形中优化函数的时候,如果按照最陡下降法来做就会沿着一个多重曲折的折线行进.这样的效果是需要很多小碎步才能接近极小值, 因此实际上是效率很低的.</p><p>请看下面的函数, 它是著名的 <ahref="https://en.wikipedia.org/wiki/Rosenbrock_function">Rosenbrock函数</a>, 使用最速下降法进行优化, 竟然整整迭代了1000次,这多少有些超出了我们的接受范围.</p><figure><img src="../img/banana_steepdesc.gif" alt="Rosenbrock 函数" /><figcaption aria-hidden="true">Rosenbrock 函数</figcaption></figure><p>为什么会造成这样的结果? 因为最速下降法的两次线搜索的位移是正交的,这其实一定程度上破坏了搜索的成果. 如果引入参数, 确保搜索方向<spanclass="math inline">\(\boldsymbol{p}_i\)</span>并不是只依赖于负梯度<spanclass="math inline">\(\boldsymbol{r}_i\)</span>, 而是 <spanclass="math display">\[\boldsymbol{p}_i=\boldsymbol{r}_i+\beta_{i-1}\boldsymbol{p}_{i-1}\]</span> 位置的递推式为 <span class="math display">\[\boldsymbol{x}_{i+1}=\boldsymbol{x}_i+\alpha_i\boldsymbol{p}_i\]</span> <spanclass="math inline">\(\alpha_i\)</span>可以用一维优化来求出, <spanclass="math inline">\(\beta_i\)</span>可以证明具有形式 <spanclass="math display">\[\beta_i=\frac{\boldsymbol{r}_{i+1}^\mathbf{T}\boldsymbol{r}_{i+1}}{\boldsymbol{r}_i^\mathbf{T}\boldsymbol{r}_i}\]</span></p><h3 id="步骤">步骤</h3><ol start="0" type="1"><li><p>给定<spanclass="math inline">\(\boldsymbol{p}_0=\boldsymbol{r}_0=-\displaystyle\boldsymbol{\nabla}f(\boldsymbol{x}_0)\)</span>, <spanclass="math inline">\(k=0\)</span></p></li><li><p>根据 <span class="math display">\[\phi(\alpha_k):= f(\boldsymbol{x}_k+\alpha_k\boldsymbol{p}_k)\]</span> 进行一维优化. 对于二次型可以直接利用公式计算<spanclass="math inline">\(\alpha_k\)</span> <span class="math display">\[\alpha_k=\frac{\boldsymbol{p}_k^\mathbf{T}\boldsymbol{r}_k}{\boldsymbol{p}_k^\mathbf{T}\mathbf{A}\boldsymbol{p}_k}\]</span></p></li><li><p>更新位置和残差: <span class="math display">\[\begin{aligned}\boldsymbol{x}_{k+1}&amp;=\boldsymbol{x}_k+\alpha_k\boldsymbol{p}_k\\\boldsymbol{r}_{k+1}&amp;=-\boldsymbol{\nabla}f(\boldsymbol{x}_{k+1})\qquad(\text{一般形式})\\&amp;=\boldsymbol{r}_k-\alpha_k\mathbf{A}\boldsymbol{p}_k\qquad(二次型)\end{aligned}\]</span></p></li><li><p>判定循环终止条件, 如果满足即跳出循环, 否则继续.</p></li><li><p>更新搜索方向 <span class="math display">\[\begin{aligned}\beta_k&amp;=\frac{\boldsymbol{r}_{k+1}^\mathbf{T}\boldsymbol{r}_{k+1}}{\boldsymbol{r}_k^\mathbf{T}\boldsymbol{r}_k}\\\boldsymbol{p}_{k+1}&amp;=\boldsymbol{r}_{k+1}+\beta_k\boldsymbol{p}_k\end{aligned}\]</span></p></li><li><p><span class="math inline">\(k\)</span>递增<spanclass="math inline">\(1\)</span>, 将新的<spanclass="math inline">\(k,\boldsymbol{x}_k,\boldsymbol{p}_k,\boldsymbol{r}_k\)</span>带到步骤1迭代.</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算物理</category>
      
      <category>数值解和优化问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值计算</tag>
      
      <tag>极值搜索</tag>
      
      <tag>最速下降法</tag>
      
      <tag>共轭梯度法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数值解和优化问题(03)：无导数的优化方法</title>
    <link href="/posts/%E6%95%B0%E5%80%BC%E8%A7%A3%E5%92%8C%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98(03)%EF%BC%9A%E6%97%A0%E5%AF%BC%E6%95%B0%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <url>/posts/%E6%95%B0%E5%80%BC%E8%A7%A3%E5%92%8C%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98(03)%EF%BC%9A%E6%97%A0%E5%AF%BC%E6%95%B0%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>所谓优化问题, 就是求一个函数的极小值点. 极值与导数有着千丝万缕的联系,但有时我们并不需要求导就能设法求解优化问题,本节给出单元和多元函数优化方法各一例: 黄金分割搜寻法和单纯形方法.</p><table frame="void"><tr><td width="50%"><img src = "../img/gold_division.png"></td><td><img src = "../img/simplx.png"></td></tr><tr><td style="text-align: center; font-family: KaiTi; font-weight: bold;">(摘自刘川《计算物理导论》图 5.1)</td><td style="text-align: center; font-family: KaiTi; font-weight: bold;">(摘自刘川《计算物理导论》图 5.2)</td></tr></table><h2 id="黄金分割搜寻法">黄金分割搜寻法</h2><p>假设我们从预估的区域内选择三个点:<spanclass="math inline">\(x_0&lt;x_1&lt;x_3\)</span>. 它们的函数值可以计算.假如这三个函数值中最小者为<span class="math inline">\(f(x_1)\)</span>,只要函数和区域不太奇特, 那么在<span class="math inline">\((x_0,x_3)\)</span>上必然存在极小值点.</p><p>然后我们产生一个点<spanclass="math inline">\(x_2\in(x_1,x_3)\)</span>, 那么分两种情况:</p><ol type="1"><li><span class="math inline">\(f(x_1)&lt;f(x_2)\)</span>, 则<spanclass="math inline">\(f(x_1)\)</span>仍维持最小, 新区间取作<spanclass="math inline">\((x_0,x_2)\)</span>, <spanclass="math inline">\(x_1\)</span>留作比较;</li><li><span class="math inline">\(f(x_1)&gt;f(x_2)\)</span>, 则<spanclass="math inline">\(f(x_2)\)</span>成为新的最小, 新区间取作<spanclass="math inline">\((x_1,x_3)\)</span>, <spanclass="math inline">\(x_2\)</span>留作比较.</li></ol><p>那么如何得到<span class="math inline">\(x_2\)</span>呢? 设定三个长度:<span class="math display">\[a:=x_1 - x_0\ ,\qquad b := x_2 - x_1\ ,\qquad c := x_3-x_1\]</span> 两种情况下的新区间总长度分别是<spanclass="math inline">\(a+b\)</span>和<spanclass="math inline">\(c\)</span>, 我们希望两者一致. 另外,我们还希望两种新区间有相似性, 即各个点比例一致. 那么 <spanclass="math display">\[\begin{aligned}b &amp;= c - a\\\frac{b}{c} &amp;= \frac{a}{a + c}\end{aligned}\]</span> 解得 <span class="math display">\[c = \frac{\sqrt{5}+1}{2}a\ ,\qquad b = \frac{\sqrt{5}-1}{2}a\]</span> 这恰好是黄金分割比, 因此这种方法称作<strong>黄金分割搜寻法</strong>.</p><h3 id="方法总结">方法总结</h3><ol type="1"><li><p>给定区间两端点<span class="math inline">\(x_0&lt;x_3\)</span>​,由此求出两值为 <span class="math display">\[x_1 = \frac{\sqrt{5}-1}{2}x_0 + \frac{3-\sqrt{5}}{2}x_3\\x_2 = \frac{3-\sqrt{5}}{2}x_0 + \frac{\sqrt{5}-1}{2}x_3\]</span></p></li><li><p>研究结束条件<spanclass="math inline">\(g(x_0,x_1,x_2,x_3)\le\epsilon\)</span>是否满足,满足则终止, 不满足则来到步骤3.</p></li><li><p>比较<span class="math inline">\(f(x_1)\)</span>和<spanclass="math inline">\(f(x_2)\)</span>, 如果前者更小, 来到步骤4.a;如果前者更大, 来到步骤4.b.</p></li><li><p>根据上一步的情况选择其一:</p><ol type="1"><li>将<span class="math inline">\(x_0,x_1,x_2\)</span>作为新的<spanclass="math inline">\(x_0,x_2,x_3\)</span>, 新的<spanclass="math inline">\(x_1\)</span>按照步骤1计算, 进入步骤2.</li><li>将<span class="math inline">\(x_1,x_2,x_3\)</span>作为新的<spanclass="math inline">\(x_0, x_1,x_3\)</span>, 新的<spanclass="math inline">\(x_2\)</span>按照步骤1计算, 进入步骤2.</li></ol></li></ol><h2 id="单纯形方法">单纯形方法</h2><h3 id="前置知识">前置知识</h3><p>单纯形方法是适用于多元函数的无导数优化方法, 也叫 <strong>Nelder-Mead方法</strong>. 要使用这种方法, 就要先定义所谓的<strong>单纯形</strong>:</p><blockquote><p>考虑<span class="math inline">\(n\)</span>维空间中完全联通的<spanclass="math inline">\(n+1\)</span>个不共超平面的点, 任选<spanclass="math inline">\(n\)</span>个点即共超平面. 按照<spanclass="math inline">\(C_{n+1}^n\)</span>组合出的<spanclass="math inline">\(n+1\)</span>个超平面围成的几何体, 称作<spanclass="math inline">\(n\)</span>维空间的单纯形.</p></blockquote><p>举例说明即是: <span class="math inline">\(1\)</span>维的线段, <spanclass="math inline">\(2\)</span>维的三角形, <spanclass="math inline">\(3\)</span>维的四面体......</p><p>构造单纯形的方法非常简单, 给定一个出发点<spanclass="math inline">\(\vec{x}^{(0)}\)</span>, 构造另外<spanclass="math inline">\(n\)</span>个点<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="这里的构造只需要线性无关, 不需要正交性, 斜交是完全允许的.">[1]</span></a></sup><span class="math display">\[\vec{x}^{(i)}=\vec{x}^{(0)}+h_i\hat{e}_i\ ,\qquad i = 1, 2, \cdots, n\]</span> <span class="math inline">\(n+1\)</span>个点中,有三个点尤其应该关注:</p><ul><li><strong>最佳点</strong>: 函数值最小的点, 记作<spanclass="math inline">\(\vec{x}^{(m)}\)</span>.</li><li><strong>最差点</strong>: 函数值最大的点, 记作<spanclass="math inline">\(\vec{x}^{(M)}\)</span>.</li><li><strong>次差点</strong>: 函数值次大的点, 记作<spanclass="math inline">\(\vec{x}^{(\mu)}\)</span>.</li></ul><p>对于每个点定义它的<strong>对偶中心点</strong>: <spanclass="math display">\[\vec{x}_c^{(k)}=\frac{1}{n}\sum_{j=0,j\ne k}^n\vec{x}^{(j)}\]</span></p><h3 id="算法步骤">算法步骤</h3><ol type="1"><li><p>对给定的起始点确定其它<spanclass="math inline">\(n\)</span>个点和<spanclass="math inline">\(\vec{x}^{(M)},\vec{x}^{(m)},\vec{x}^{(\mu)}\)</span>.</p></li><li><p><strong>反射步骤</strong></p><ol type="1"><li><p>求出<spanclass="math inline">\(n+1\)</span>个点的<strong>样本方差</strong><spanclass="math inline">\(s^2\)</span>并与规定的误差<spanclass="math inline">\(\epsilon\)</span>​​比较, 如果更低就停止迭代,否则进行反射, 具体地: <span class="math display">\[\vec{x}_r=(\alpha+1)\vec{x}_c^{(M)}-\alpha\vec{x}^{(M)}\]</span> 其中<spanclass="math inline">\(\alpha&gt;0\)</span>是可调的反射系数.</p></li><li><p>判断函数值, 如果满足<spanclass="math inline">\(f(\vec{x}^{(m)})&lt;f(\vec{x}_r)&lt;f(\vec{x}^{(\mu)})\)</span>,则用<span class="math inline">\(\vec{x}_r\)</span>替代<spanclass="math inline">\(\vec{x}^{(M)}\)</span>(尽管还有比它更差的点)并回到步骤2.a;如果<spanclass="math inline">\(f(\vec{x}_r)&lt;f(\vec{x}^{(m)})\)</span>,即它成了最佳的点, 进入步骤3; 如果<spanclass="math inline">\(f(\vec{x}_r)&gt;f(\vec{x}^{(\mu)})\)</span>,进入步骤4.</p></li></ol></li><li><p><strong>扩展步骤</strong></p><ol type="1"><li><p>定义新的扩展点<span class="math inline">\(\vec{x}_e\)</span>​​,使得 <span class="math display">\[\vec{x}_e=\beta\vec{x}_r+(1-\beta)\vec{x}_c^{(M)}\]</span> 其中<spanclass="math inline">\(\beta&gt;1\)</span>是一个可调的扩展参数.</p></li><li><p>判断函数值, 如果<spanclass="math inline">\(f(\vec{x}_e)&lt;f(\vec{x}^{(m)})\)</span>,则用<span class="math inline">\(\vec{x}_e\)</span>替代<spanclass="math inline">\(\vec{x}^{(M)}\)</span>; 否则用<spanclass="math inline">\(\vec{x}_r\)</span>替代<spanclass="math inline">\(\vec{x}^{(M)}\)</span>.不管用谁替代都回到步骤2.</p></li></ol></li><li><p><strong>收缩步骤</strong></p><ol type="1"><li><p>判断函数值. 如果<spanclass="math inline">\(f(\vec{x}_r)&lt;f(\vec{x}_c^{(M)})\)</span>,则极小值点位于<span class="math inline">\(\vec{x}_r\)</span>和<spanclass="math inline">\(\vec{x}_c^{(M)}\)</span>​之间, 收缩点选为 <spanclass="math display">\[\vec{x}_{con}=\gamma\vec{x}_r+(1-\gamma)\vec{x}_c^{(M)}\,\qquad\gamma\in(0,1)\]</span> 如果<span class="math inline">\(f(\vec{x}_r)\gef(\vec{x}_c^{(M)})\)</span>, 则极小值点位于<spanclass="math inline">\(\vec{x}^{(M)}\)</span>和<spanclass="math inline">\(\vec{x}_c^{(M)}\)</span>之间, 收缩点选为 <spanclass="math display">\[\vec{x}_{con}=\gamma\vec{x}^{(M)}+(1-\gamma)\vec{x}_c^{(M)}\]</span></p></li><li><p>判断函数值, 如果<spanclass="math inline">\(f(\vec{x}_{con})&lt;f(\vec{x}^{(M)})\)</span>且<spanclass="math inline">\(f(\vec{x}_{con})&lt;f(\vec{x}_r)\)</span>, 用<spanclass="math inline">\(\vec{x}_{con}\)</span>替代<spanclass="math inline">\(\vec{x}^{(M)}\)</span>回到步骤2; 否则,回到步骤1将每个<span class="math inline">\(h_k\)</span>都减半,重新构造各个点.</p></li></ol></li></ol><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>这里的构造只需要线性无关,不需要正交性, 斜交是完全允许的.<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算物理</category>
      
      <category>数值解和优化问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值计算</tag>
      
      <tag>极值搜索</tag>
      
      <tag>黄金分割搜寻法</tag>
      
      <tag>单纯形方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数值解和优化问题(02)：Aitken 算法, Steffensen 算法</title>
    <link href="/posts/%E6%95%B0%E5%80%BC%E8%A7%A3%E5%92%8C%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98(02)%EF%BC%9AAitken%20%E7%AE%97%E6%B3%95,%20Steffensen%20%E7%AE%97%E6%B3%95/"/>
    <url>/posts/%E6%95%B0%E5%80%BC%E8%A7%A3%E5%92%8C%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98(02)%EF%BC%9AAitken%20%E7%AE%97%E6%B3%95,%20Steffensen%20%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="aitken---δ²-加速算法">Aitken - Δ² 加速算法</h2><p>如果我们已经有了一个收敛于函数<spanclass="math inline">\(f(x)\)</span>的根<spanclass="math inline">\(\xi\)</span>的一个迭代序列<spanclass="math inline">\(\{x_i\}\)</span>,希望构造一个收敛速度更快的迭代序列<spanclass="math inline">\(\{x_i&#39;\}\)</span>. 为此, 引入新参数<spanclass="math inline">\(k\)</span>: <span class="math display">\[k:=\frac{x_{i+1}-\xi}{x_i-\xi}\]</span> 假定<span class="math inline">\(k\)</span>和<spanclass="math inline">\(\xi\)</span>是不依赖于<spanclass="math inline">\(i\)</span>的常数(基本不可能),那么它们可以用相邻的三个元素表示出来: <span class="math display">\[\begin{aligned}k &amp;= \frac{x_{i+2}-x_{i+1}}{x_{i+1}-x_i}\\\xi &amp;= \frac{x_ix_{i+2}-x_{i+1}^2}{x_{i+2}-2x_{i+1}+x_i}\end{aligned}\]</span> 引入差分算符<span class="math inline">\(\Delta x_i :=x_{i+1}-x_i\)</span>, 则 <span class="math display">\[\xi=x_i-\displaystyle\frac{(\Delta x_i)^2}{\Delta^2 x_i}\]</span> 直接拿它构造新序列, 得到 <span class="math display">\[\boxed{x_i&#39;=x_i-\frac{(\Delta x_i)^2}{\Delta^2x_i}=x_i-\frac{(x_{i+1}-x_i)^2}{x_{i+2}-2x_{i+1}+x_i}}\]</span> 这就是所谓的 <strong>Aitken-Δ² 加速算法</strong>,按照这个算法得到的新序列必然收敛得更快.</p><h2 id="steffensen-算法">Steffensen 算法</h2><p>我们使用迭代函数的形式描述迭代过程 <span class="math display">\[x_{i+1}=\Phi(x_i)\ ;\qquad\xi=\Phi(\xi)\]</span> 相应地, Aitken 算法的形式可以改写为 <spanclass="math display">\[\begin{aligned}x_i&#39;&amp;=x_i-\frac{(\Phi(x_i)-x_i)^2}{\Phi[\Phi(x_i)]-2\Phi(x_i)+x_i}\\&amp;=\frac{x_i\Phi[\Phi(x_i)]-[\Phi(x_i)]^2}{\Phi[\Phi(x_i)]-2\Phi(x_i)+x_i}\end{aligned}\]</span> 进一步引入新函数 <span class="math display">\[\Psi(x):=\frac{x\Phi[\Phi(x)]-[\Phi(x)]^2}{\Phi[\Phi(x)]-2\Phi(x)+x}\\x&#39;_i=\Psi(x_i)\]</span> 我们已知<span class="math inline">\(x_i&#39;\)</span>比<spanclass="math inline">\(x_i\)</span>更快, 不如把它定义成所谓的<spanclass="math inline">\(x_{i+1}\)</span>, 则新迭代方法告诉我们 <spanclass="math display">\[x_{i+1}=\Psi(x_i)\]</span></p>]]></content>
    
    
    <categories>
      
      <category>计算物理</category>
      
      <category>数值解和优化问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值计算</tag>
      
      <tag>数值求解</tag>
      
      <tag>Aitken 算法</tag>
      
      <tag>Steffensen 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数值解和优化问题(01)：对分法, 切线法和割线法</title>
    <link href="/posts/%E6%95%B0%E5%80%BC%E8%A7%A3%E5%92%8C%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98(01)%EF%BC%9A%E5%AF%B9%E5%88%86%E6%B3%95,%20%E5%88%87%E7%BA%BF%E6%B3%95%E5%92%8C%E5%89%B2%E7%BA%BF%E6%B3%95/"/>
    <url>/posts/%E6%95%B0%E5%80%BC%E8%A7%A3%E5%92%8C%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98(01)%EF%BC%9A%E5%AF%B9%E5%88%86%E6%B3%95,%20%E5%88%87%E7%BA%BF%E6%B3%95%E5%92%8C%E5%89%B2%E7%BA%BF%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>本章介绍两类问题, 数值解问题(即解方程)和优化问题(即查找极小值点),它们一定程度上很像. <strong>我们默认本章的讨论对象,即某些一元或多元函数, 在讨论的区间上具有连续导数.</strong>我们不使用特定的公式进行近似估计,而是从一个初始点开始进行迭代逼近最优解. 本节就要介绍三类迭代求根法.</p><h2 id="对分法">对分法</h2><p>给定一个函数<span class="math inline">\(f(x)\)</span>,如果我们已知它在闭区间<spanclass="math inline">\([a,b]\)</span>上连续并且满足<spanclass="math inline">\(f(a)f(b)&lt;0\)</span>, 那么最直接的求根方法就是<strong>对分法</strong>, 也称 <strong>二分法</strong>.</p><p>对分法的流程十分简单, 每次我们将区间二分, 计算中间位置<spanclass="math inline">\(c=\displaystyle\frac{a+b}{2}\)</span>的函数值<spanclass="math inline">\(f(c)\)</span>, 如果它和<spanclass="math inline">\(f(a)\)</span>或<spanclass="math inline">\(f(b)\)</span>中的某个值异号,则可以知道两个子区间中存在根的区间, 如是递归,就能锁定根附近的一个小区间.</p><p>对分法的优势十分明显, 如果<spanclass="math inline">\(f(x)\)</span>的导数计算不便(尽管存在),那么对分法作为一种只涉及函数值计算的方法是很便利的; 另外,很多时候求根过程本身并没有多么费时, 或者不追求收敛速度,那么对分法也是较好的选择, 它的误差随迭代次数而指数衰减.</p><h2 id="newton-raphson-法">Newton-Raphson 法</h2><p>我们同样考虑一个一元函数<spanclass="math inline">\(f(x)\)</span>的根. 假设它有一根<spanclass="math inline">\(\xi\)</span>, 并且搜索域足够光滑并处在<spanclass="math inline">\(\xi\)</span>附近, 使得函数<spanclass="math inline">\(f(x)\)</span>可以作 Taylor 展开: <spanclass="math display">\[f(\xi)=0\ ;\qquad f(\xi)=f(x_0)+f&#39;(x_0)(\xi-x_0)+o(\xi-x_o)\]</span> 抛弃高阶无穷小, 也就是作线性近似,有 <spanclass="math display">\[\begin{aligned}&amp;\boxed{\xi\approx x_0-\frac{f(x_0)}{f&#39;(x_0)}}\\\text{或者写作 }&amp;\boxed{x_{i+1}=x_i-\frac{f(x_i)}{f&#39;(x_i)}}\end{aligned}\]</span> 这个表达式就是所谓的 <strong>Newton-Raphson</strong> 法,将求得的<span class="math inline">\(\xi\)</span>值作为下一轮的<spanclass="math inline">\(x_0\)</span>进行迭代, 直到误差收敛到想要的范围,因为涉及且仅涉及一阶导数计算, 又称为 <strong>切线法</strong>.</p><p>切线法的优势在于更快的收敛速度. 令<spanclass="math inline">\(\epsilon_i=x_i-\xi\)</span>, 有 <spanclass="math display">\[\epsilon_{i+1}=\epsilon_{i}-\frac{f(x_i)}{f&#39;(x_i)}\]</span> 考虑到后一项的 Taylor 近似公式 <span class="math display">\[\begin{aligned}f(x_i)&amp;=f(\xi)+f&#39;(\xi)\cdot\epsilon_i+o(\epsilon_i)\approxf&#39;(\xi)\cdot\epsilon_i\\f&#39;(x_i)&amp;=f&#39;(\xi)+f&#39;&#39;(\xi)\cdot\epsilon_i +o(\epsilon_i)\approx f&#39;(\xi)+f&#39;&#39;(\xi)\cdot\epsilon_i\end{aligned}\]</span> 得到 <span class="math display">\[\epsilon_{i+1}\sim\epsilon_i^2\]</span> Newton 法也并非没有缺陷. 迭代公式依赖于函数导数,如果在搜索域内同时存在极值, 使得<spanclass="math inline">\(f&#39;(x_i)\)</span>很小,那么可能造成某一步的位移很大, 误差急剧变大, 慢慢回来是很困难的,极值点(驻点)对 Newton 法干扰很大.</p><h3 id="高阶推广">高阶推广</h3><p>我们可以作抛物近似, 它给出一个比较复杂的公式: <spanclass="math display">\[x_{i+1}=x_i-\frac{f(x_i)\pm\sqrt{f&#39;(x_i)^2-2f(x_i)f&#39;&#39;(x_i)}}{f&#39;&#39;(x_i)}\]</span> 更高阶的推广过于复杂, 而且导数计算不便, 故而不用,这个二阶推广使用也较少.</p><h3 id="多元推广">多元推广</h3><p>我们还可以把一元方程推广为多元的方程组. 给定线性独立的方程组 <spanclass="math display">\[f_k(\vec{x})=0\ ,\qquad k=1,2,\cdots,n\]</span> 其中<spanclass="math inline">\(\vec{x}=(x^{(1)},x^{(2)},\cdots,x^{(n)})\)</span>.同样地, 进行 Taylor 展开 <span class="math display">\[\vec{f}(\vec{\xi})=\boldsymbol{0}\ ;\qquad\vec{f}(\vec{\xi})=\vec{f}(\vec{x}_0)+\boldsymbol{\nabla}\vec{f}(\vec{x}_0)\cdot(\vec{\xi}-\vec{x}_0)+o(|\vec{\xi}-\vec{x}_0|)\]</span> 其中<span class="math inline">\(\boldsymbol{\nabla}\vec{f}(\vec{x}_0)\)</span>自然是个张量, 并且满足 <spanclass="math display">\[[\boldsymbol{\nabla} \vec{f}(\vec{x}_0)]_{jk}=\frac{\partialf_j(\vec{x})}{\partial x^{(k)}}\]</span> 就是 Jacobi 矩阵. 只要它在搜索域上可逆,就有<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote">&lt;spanclass="hint--top hint--rounded" aria-label="等价于 Jacobi 行列式非零,这实际上就是"线性独立"想表达的意思"&gt;[1]</span></a></sup> <spanclass="math display">\[\vec{x}_{i+1}=\vec{x}_i-[\boldsymbol{\nabla}\vec{f}(\vec{x}_i)]^{-1}\cdot\vec{f}(\vec{x}_i)\]</span> 当维数<span class="math inline">\(n=1\)</span>​时,退化为一元函数的切线法.</p><h2 id="割线法">割线法</h2><p>割线法和切线法类似, 它是导数不太好算时的平替, 我们用割线代替切线:<span class="math display">\[f&#39;(x_i)\approx\frac{f(x_i)-f(x_{i-1})}{x_i-x_{i-1}}\]</span> 那么割线法的迭代公式为 <span class="math display">\[x_{i+1}=x_i-\frac{(x_i-x_{i-1})f(x_i)}{f(x_i)-f(x_{i-1})}\]</span> 这实际上意味着<spanclass="math inline">\(x\)</span>能够具有下标<spanclass="math inline">\(-1\)</span>, 也就是说我们要给定两个初始位置<spanclass="math inline">\(x_{-1}\)</span>和<spanclass="math inline">\(x_0\)</span>. 如果它们之间存在驻点,割线法同样会失败; 只要正确运用割线法, 其收敛速度略慢于切线法,但明显快于对分法.</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>等价于 Jacobi 行列式非零,这实际上就是"线性独立"想表达的意思<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算物理</category>
      
      <category>数值解和优化问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值计算</tag>
      
      <tag>数值求解</tag>
      
      <tag>对分法</tag>
      
      <tag>Newton-Raphson 法</tag>
      
      <tag>割线法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微积分数值计算(02)：外推积分法, Gauss 积分法</title>
    <link href="/posts/%E5%BE%AE%E7%A7%AF%E5%88%86%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97(02)%EF%BC%9A%E5%A4%96%E6%8E%A8%E7%A7%AF%E5%88%86%E6%B3%95,%20Gauss%20%E7%A7%AF%E5%88%86%E6%B3%95/"/>
    <url>/posts/%E5%BE%AE%E7%A7%AF%E5%88%86%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97(02)%EF%BC%9A%E5%A4%96%E6%8E%A8%E7%A7%AF%E5%88%86%E6%B3%95,%20Gauss%20%E7%A7%AF%E5%88%86%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="外推积分法">外推积分法</h2><p>所谓 <strong>外推积分法</strong>, 就是将积分区间大小为<spanclass="math inline">\(h\)</span>的数值积分值, 按照一定的形式外推至<spanclass="math inline">\(h\to0\)</span>的情况.比如我们如果考虑积分值满足如下表达式 <span class="math display">\[I(h)=\tau_0+\tau_1h^2+\cdots+\tau_mh^{2m}+\cdots\]</span> 那么我们就可以通过递推计算获得关于<spanclass="math inline">\(h\)</span>的某一阶的数值积分.</p><p>外推积分法的基础是 <strong>Euler-Maclaurin 公式</strong> <spanclass="math display">\[T(h)-\int_a^bf(t)dt=\sum_{k=1}^m\frac{B_{2k}h^{2k}}{(2k)!}[f^{(2k-1)}(a)-f^{(2k-1)}(b)]-\frac{B_{2m+2}h^{2m+2}}{(2m+2)!}f^{(2m+2)}(\xi)\,\ \xi\in[a,b]\]</span> 其中, <span class="math inline">\(T(h)\)</span>和<spanclass="math inline">\(\displaystyle\int_a^bf(t)dt\)</span>分别是微元法给出的积分值和真实的积分值.<span class="math inline">\(B_{2k}\)</span>是所谓的 Bernoulli 数, 即<span class="math display">\[\frac{z}{e^z-1}=\sum_{n=0}^\infty\frac{B_n}{n!}z^n\]</span> 根据这个公式, <spanclass="math inline">\(T(h)\)</span>可以写为形如 <spanclass="math display">\[T(h)=\tau_0+\tau_1h^2+\cdots+\tau_mh^{2m}+o(h^{2m})\]</span> 的多项式. 因此取多个<spanclass="math inline">\(h\)</span>并计算<spanclass="math inline">\(T(h)\)</span>​的值, 由此进行多项式插值,得到的插值函数的零阶项, 便是对积分的数值计算.</p><h3 id="neville-形式">Neville 形式</h3><p>我们可以模拟 Neville 插值法进行外推. 首先, 选取一个整数序列<spanclass="math inline">\(\{N_i\}\)</span>来调整<spanclass="math inline">\(h\)</span>, 即<spanclass="math inline">\(\{h_i\}=\{\displaystyle\frac{b-a}{N_i}\}\)</span>.为了方便, 将<span class="math inline">\(T(h_k)\)</span>记作<spanclass="math inline">\(T_{k0}\)</span>. 而内插的<spanclass="math inline">\(m\)</span>阶多项式记为<spanclass="math inline">\(P_{mm}(h)\)</span>, 它显然满足 <spanclass="math display">\[P_{mm}(h_k)=T_{k0}\]</span> 假设<span class="math inline">\(P_{jk}(h)\)</span>是关于<spanclass="math inline">\(h^2\)</span>的<spanclass="math inline">\(k\)</span>次插值函数, 支撑点为<spanclass="math inline">\(\{h_{j-k},\cdots,h_{j}\}\)</span>. 模仿 Neville迭代有 <span class="math display">\[P_{jk}=\frac{\displaystyle\frac{h_{j-k}^2}{h_j^2}P_{j,k-1}-P_{j-1,k-1}}{\displaystyle\frac{h_{j-k}^2}{h_j^2}-1}\]</span> 我们可以这么表示迭代过程: <span class="math display">\[\begin{pmatrix}T_{00} &amp;&amp; T_{10} &amp;&amp; T_{20} &amp;&amp; \cdots &amp;&amp;T_{m0}\newline&amp; \searrow &amp; \downarrow &amp; \searrow &amp; \downarrow&amp;\searrow &amp; \cdots &amp; \searrow &amp; \downarrow\newline&amp;&amp;P_{11} &amp;&amp; P_{21} &amp;&amp; \cdots &amp;&amp; P_{m1}\newline&amp;&amp;&amp; \searrow &amp; \downarrow &amp;\searrow &amp; \cdots&amp; \searrow &amp; \downarrow\newline&amp;&amp;&amp;&amp; P_{22} &amp;&amp; \cdots &amp;&amp; P_{m2}\newline&amp;&amp;&amp;&amp;&amp;\searrow &amp; \cdots &amp; \searrow &amp;\downarrow\newline&amp;&amp;&amp;&amp;&amp;&amp; \cdots &amp;&amp; \cdots\newline&amp;&amp;&amp;&amp;&amp;&amp;&amp; \searrow &amp; \downarrow\newline&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;P_{mm}\end{pmatrix}\]</span></p><h2 id="gauss-积分法">Gauss 积分法</h2><p>如果一个函数可以利用正交多项式的展开进行近似,我们就可以利用这个展开计算定积分.</p><p>现在先给定积分区间<spanclass="math inline">\([a,b]\)</span>以及一个内积空间<spanclass="math inline">\(\mathbb{V}\)</span>, 权函数为<spanclass="math inline">\(\omega\)</span>, 主要研究对象为函数<spanclass="math inline">\(f\in\mathbb{V}\)</span>.内积空间上全体最高次系数为<span class="math inline">\(1\)</span>的<spanclass="math inline">\(j\)</span>次多项式, 构成了内积空间<spanclass="math inline">\(\mathbb{V}\)</span>的真子集, 记作<spanclass="math inline">\(\mathbb{P}_j\)</span>.</p><p>我们不加证明地指出一个定理系统:</p><h3 id="正交多项式与-chebyshev-系统">正交多项式与 Chebyshev 系统</h3><ol type="1"><li><p><strong>正交基的存在性</strong></p><p>存在一系列多项式<span class="math inline">\(p_k\in\mathbb{P}_k\ ,\k=0,1,\cdots\)</span>​​, 满足正交关系 <span class="math display">\[(p_j,p_k)=0\ ,\ j\ne k\]</span></p></li><li><p><strong>Gram-Schimidt 正交化方法</strong></p><p>这个正交基可以由下列递推关系给出 <span class="math display">\[p_{k+1}(x)=(x-\alpha_{k+1})p_k(x)-\beta_{k+1}^2p_{k-1}(x)\newlinep_0(x)\equiv1\ ,\ \text{规定 }p_{-1}(x)\equiv0\]</span> 其中, 参数<span class="math inline">\(\alpha\)</span>和<spanclass="math inline">\(\beta\)</span>分别为 <span class="math display">\[\alpha_{k+1}=\frac{(xp_{k+1},p_{k+1})}{(p_{k+1},p_{k+1})}\\\beta_{k+1}^2=\frac{(p_k,p_k)}{(p_{k-1},p_{k-1})}\\(\text{规定 }\beta^2_1=0)\]</span></p></li><li><p><strong>零点的性质</strong></p><p><span class="math inline">\(p_k(x)\)</span>的<spanclass="math inline">\(k\)</span>个零点都是单重实根, 并且都在<spanclass="math inline">\([a,b]\)</span>上</p></li><li><p><strong>Haar 条件</strong></p><p>给定<span class="math inline">\(n\)</span>个两两不同的自变量<spanclass="math inline">\(\{t_i\}_{0\sim n-1}\)</span>, 下列系数矩阵是可逆的<span class="math display">\[\begin{aligned}\boldsymbol{A}&amp;=\begin{pmatrix}p_0(t_0) &amp; \cdots &amp; p_0(t_{n-1})\newline\vdots &amp; \cdots &amp; \vdots\newlinep_{n-1}(t_0) &amp; \cdots &amp; p_{n-1}(t_{n-1})\end{pmatrix}\newline\newline(&amp;\text{或者 }a_{jk}=p_{j-1}(t_{k-1}))\end{aligned}\]</span></p></li></ol><p>Haar 条件意味着什么呢? 当我们计算一个插值问题时, 插值函数为 <spanclass="math display">\[P_{N}(x)=\sum_{k=0}^{N-1}c_kp_k(x)\]</span> 支撑点为<span class="math inline">\(\{(t_i,f_i)\}_{0\simN-1}\)</span>, 因此它满足一个线性方程组 <span class="math display">\[\sum_{k=0}^{N-1}p_k(t_{j})c_k=f_j\]</span> 即 <span class="math display">\[\begin{pmatrix}c_0 &amp; c_1 &amp; \cdots &amp;c_{N-1}\end{pmatrix}\cdot\boldsymbol{A}=\begin{pmatrix}f_0 &amp; f_1 &amp; \cdots &amp; f_{N-1}\end{pmatrix}\]</span> 它有唯一解的条件是<spanclass="math inline">\(\boldsymbol{A}\)</span>具有full rank,也就要求可逆, 即所谓的 Haar 条件保证了插值问题解的唯一性.满足以上几个条件的一系列多项式, 称之为 <strong>Chebyshev系统</strong>.</p><h3 id="gauss-点-权重因子">Gauss 点, 权重因子</h3><p>我们把 Gram-Schimidt 正交化方法中的参数排成一个三对角矩阵 <spanclass="math display">\[\boldsymbol{J}_n=\begin{pmatrix}\alpha_1 &amp; \beta_2 &amp;\newline\beta_2 &amp; \alpha_2 &amp; \ddots\newline&amp; \ddots &amp; \ddots &amp; \ddots\newline&amp; &amp; \ddots &amp;\alpha_{n-1} &amp; \beta_n\newline&amp; &amp; &amp; \beta_n &amp; \alpha_n\end{pmatrix}\]</span> 定义函数 <span class="math display">\[p_n(x)=\det(x\boldsymbol{I}_n-\boldsymbol{J}_n)\]</span> 明显有 <span class="math display">\[p_n(x)=(x-\alpha_n)p_{n-1}(x)-\beta_n^2p_{n-2}(x)\]</span> 这明显就是之前定义的多项式基<spanclass="math inline">\(\{p_i(x)\}\)</span>, 而<spanclass="math inline">\(\boldsymbol{J}_n\)</span>的本征值, 恰好是<spanclass="math inline">\(p_n(x)\)</span>的<spanclass="math inline">\(n\)</span>个零点.</p><p>假设我们选择了这<spanclass="math inline">\(n\)</span>个零点作为积分的 <strong>Gauss点</strong>: <span class="math display">\[I[f]\approx\sum_{j=1}^nw_jf(x_j)\]</span> <span class="math inline">\(w_j\)</span>称为<strong>权重因子</strong>, 为了保证支撑点都有效, 并且不出现正负相消,它们应该都为正. 考虑在正交多项式基上展开<spanclass="math inline">\(\displaystylef(x)\approx\sum_{k=0}^{n-1}c_kp_k(x)\)</span>, 近似替代<spanclass="math inline">\(f\)</span>, 我们希望三个约等号联系起一个等号:<span class="math display">\[\sum_{k=0}^{n-1}c_k\int_a^b\omega(x)p_k(x)dx=\sum_{k=0}^{n-1}c_k\sum_{j=1}^nw_jp_k(x_j)\]</span> 观察左边, 不难发现其实只有<spanclass="math inline">\(k=0\)</span>项存在, 因为积分相当于<spanclass="math inline">\(p_0\equiv1\)</span>和<spanclass="math inline">\(p_k\)</span>的内积.为了得到普适的式子(指对于任何<spanclass="math inline">\(\{c_i\}\)</span>总能取等或者近似取等), 有 <spanclass="math display">\[\sum_{j=1}^nw_jp_k(x_j)=\begin{cases}\begin{aligned}\displaystyle(p_0,p_0)\qquad k=0&amp;\newline\newline\displaystyle0\qquad \text{otherwise}&amp;\end{aligned}\end{cases}\]</span></p><h3 id="gauss-积分法总结">Gauss 积分法总结</h3><p>对于一个函数<spanclass="math inline">\(f\in\mathbb{C}^{2n}[a,b]\)</span>和一个正交多项式基<spanclass="math inline">\(\{p_i\}\)</span>, 取<spanclass="math inline">\(p_n\)</span>的零点<spanclass="math inline">\(\{x_i\}_{1\sim n}\)</span>为 Gauss 点, 线性方程组<span class="math display">\[\sum_{j=1}^np_k(x_j)w_j=\begin{cases}\begin{aligned}\displaystyle(p_0,p_0)\qquad k=0&amp;\newline\newline\displaystyle0\qquad \text{otherwise}&amp;\end{aligned}\end{cases}\]</span> 的解<span class="math inline">\(\vec{w}\)</span>为权重因子,则可以用如下公式近似替代定积分: <span class="math display">\[\int_a^b\omega(x)f(x)dx=\sum_{j=1}^nw_jf(x_j)+\frac{f^{(2n)}(\xi)}{(2n)!}(p_n,p_n)\]</span> 后一项表示误差, <spanclass="math inline">\(\xi\)</span>是<spanclass="math inline">\([a,b]\)</span>上的某个数.</p>]]></content>
    
    
    <categories>
      
      <category>计算物理</category>
      
      <category>微积分数值计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值计算</tag>
      
      <tag>数值微积分</tag>
      
      <tag>外推积分法</tag>
      
      <tag>Gauss 积分法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微积分数值计算(01)：简单的微积分方法</title>
    <link href="/posts/%E5%BE%AE%E7%A7%AF%E5%88%86%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97(01)%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E5%BE%AE%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95/"/>
    <url>/posts/%E5%BE%AE%E7%A7%AF%E5%88%86%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97(01)%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E5%BE%AE%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>本节给出一些相当trivial的微积分的数值计算方法.</p><h2 id="数值微分">数值微分</h2><h3 id="差分法">差分法</h3><p>从定义出发即可, 与数学不同的是, 我们无法做到计算"无穷小",它压根不是个数, 只能尽量给出较小的差分长度: <spanclass="math display">\[f&#39;(x)\approx\frac{f(x+h)-f(x)}{h}\]</span> 对<span class="math inline">\(f(x)\)</span>作展开, 即<spanclass="math inline">\(f(x+h)=f(x)+c_1h+c_2h^2+\cdots\)</span>, 得到<span class="math display">\[f&#39;(x)\approx c_1+c_2h+o(h)\]</span> 这给出<span class="math inline">\(\sim h\)</span>的误差.不难想到一个改进方案 <span class="math display">\[f&#39;(x)\approx\frac{f(x+h)-f(x-h)}{2h}\]</span> 同样代入展开式, 得到 <span class="math display">\[f&#39;(x)\approx c_1+c_3h^2+o(h^2)\]</span> 它给出<span class="math inline">\(\sim h^2\)</span>的误差.</p><h3 id="基函数法">基函数法</h3><p>当然还有相对复杂的计算方法, 比如, 如果已经有<spanclass="math inline">\(f(x)\)</span>​的 Chebyshev 展开 <spanclass="math display">\[f(x)\approx\sum_{k=0}^Nc_kT_k(x)\]</span> 那么它的导数可以表示为 <span class="math display">\[f&#39;(x)\approx\sum_{k=0}^Nc_k&#39;T_k(x)\]</span> 其中, <spanclass="math inline">\(c_{k-1}&#39;=c_{k+1}&#39;+2kc_k\)</span>,并且<span class="math inline">\(c_{N}&#39;=c_{N-1}&#39;=0\)</span>.</p><h2 id="数值积分的-newton-cortes-方法">数值积分的 Newton-Cortes方法</h2><h3 id="微元法">微元法</h3><p>微元法实际上不是这里的 Newton - Cortes 方法,它只是从定积分定义出发的方案. 考虑一个函数<spanclass="math inline">\(f(x)\)</span>在闭区间<spanclass="math inline">\([a,b]\)</span>上可积, 它的定积分为 <spanclass="math display">\[\int_a^bf(x)dx=\lim_{\lambda\to0^+}\sum_{l=1}^Nf(\xi_l)\Delta x_l\]</span> 其中将区间<spanclass="math inline">\([a,b]\)</span>分割为<spanclass="math inline">\(N\)</span>个子区间<spanclass="math inline">\((x_{l-1},x_l)\ ,\ l=1,2,\cdots,N\)</span>, <spanclass="math inline">\(\Delta x_l=x_l-x_{l-1}\)</span>, <spanclass="math inline">\(\xi_l\in(x_{l-1},x_l)\)</span>. 而<spanclass="math inline">\(\lambda\)</span>则是最大的区间长度, 即 <spanclass="math display">\[\lambda=\max\{\Delta x_1,\Delta x_2,\cdots,\Delta x_N\}\]</span> 和差分法类似, 我们实现不了<spanclass="math inline">\(\lambda\to0^+(N\to\infty)\)</span>的无穷细致,那就足够细致. 取分割方案为<span class="math inline">\(N\)</span>等分, 即<span class="math display">\[x_k=a+\frac{b-a}{N}\times k\newline\Delta x_l=\lambda=\frac{b-a}{N}\]</span> 并对每一个区间使用梯形法则, 得到 <span class="math display">\[\int_a^bf(x)dx\approx\frac{b-a}{N}\times(\frac{f(x_0)}{2}+\sum_{j=1}^{N-1}f(x_j)+\frac{f(x_N)}{2})\]</span></p><h3 id="newton-cortes-方法">Newton-Cortes 方法</h3><p>这个方法同样是具有上述样本点<span class="math inline">\((x_k,f(x_k))\,\ k=0,1,\cdots,N\)</span>​. 不同的是, 我们先进行 Lagrange 插值 <spanclass="math display">\[P_N(x)=\sum_{k=0}^Nf(x_k)L_k(x)\]</span> 用插值函数的定积分近似替代真实定积分, 有 <spanclass="math display">\[\int_a^bf(x)dx=\sum_{k=0}^Nf(x_k)\int_a^bL_k(x)dx\]</span> 其中 <span class="math display">\[L_k(x)=\prod_{m\ne k}\frac{x-x_m}{x_k-x_m}=\Lambda_k(t)=\prod_{m\nek}\frac{t-m}{k-m}\ ,\ t=\frac{x-a}{b-a}\times N\]</span> 于是得到著名的 <strong>Newton-Cortes 公式</strong>: <spanclass="math display">\[\boxed{\int_a^bf(x)dx\approx\frac{b-a}{N}\sum_{k=0}^N\alpha_kf(x_k)}\]</span> 其中 <span class="math display">\[\alpha_k=\int_0^N\prod_{m\ne k}^{0\sim N}\frac{t-m}{k-m}dt\]</span></p><h3 id="newton-cortes-方法的应用">Newton-Cortes 方法的应用</h3><p>我们给出一些常用的公式:</p><ol type="1"><li><p><span class="math inline">\(N=1\)</span>, 梯形法则 <spanclass="math display">\[I=\displaystyle\frac{b-a}{2}[f(x_0)+f(x_1)]\]</span></p></li><li><p><span class="math inline">\(N=2\)</span>​, Simpson 公式 <spanclass="math display">\[I=\displaystyle\frac{b-a}{6}[f(x_0)+4f(x_1)+f(x_2)]\]</span></p></li><li><p><span class="math inline">\(N=3\)</span>, <spanclass="math inline">\(\displaystyle\frac{3}{8}\)</span>​规则 <spanclass="math display">\[I=\displaystyle\frac{b-a}{8}[f(x_0)+3f(x_1)+3f(x_2)+f(x_3)]\]</span></p></li><li><p><span class="math inline">\(N=4\)</span>​​, Milne 规则 <spanclass="math display">\[I=\displaystyle\frac{b-a}{90}[7f(x_0)+32f(x_1)+12f(x_2)+32f(x_3)+7f(x_4)]\]</span></p></li><li><p><span class="math inline">\(N=6\)</span>, Weddle 规则 <spanclass="math display">\[I=\displaystyle\frac{b-a}{840}[41f(x_0)+216f(x_1)+27f(x_2)+272f(x_3)+27f(x_4)+216f(x_5)+41f(x_6)]\]</span></p></li></ol><p><span class="math inline">\(N&gt;6\)</span>由于正负相消, 不太有效,此处不表.</p><p>需要注意的是, 这些公式并不代表我们真的只进行<spanclass="math inline">\(N\)</span>次分割. 例如Simpson公式,绝不意味着我们只对<spanclass="math inline">\([a,b]\)</span>进行一次分割,完全可以先细致地分为多个子区间, 再在每个子区间上单独使用Simpson公式.</p>]]></content>
    
    
    <categories>
      
      <category>计算物理</category>
      
      <category>微积分数值计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值计算</tag>
      
      <tag>Newton-Cortes 方法</tag>
      
      <tag>数值微积分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数数值计算(04)：Clenshaw 逆向迭代, Padé 近似</title>
    <link href="/posts/%E5%87%BD%E6%95%B0%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97(04)%EF%BC%9AClenshaw%20%E9%80%86%E5%90%91%E8%BF%AD%E4%BB%A3,%20Pad%C3%A9%20%E8%BF%91%E4%BC%BC/"/>
    <url>/posts/%E5%87%BD%E6%95%B0%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97(04)%EF%BC%9AClenshaw%20%E9%80%86%E5%90%91%E8%BF%AD%E4%BB%A3,%20Pad%C3%A9%20%E8%BF%91%E4%BC%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="clenshaw-逆向迭代">Clenshaw 逆向迭代</h2><p>真正用类似的展开来算目标函数值的时候, 我们可以采用 Clenshaw提出的逆向迭代的算法. 先回顾对一个函数展开的近似方案.</p><p>首先有一个可展开的函数<span class="math inline">\(f(x)\)</span>,以及一个基<spanclass="math inline">\(\{P_i(x)\}\)</span>(不一定要求正交归一),对于无穷维的基, 在<span class="math inline">\(i=N\)</span>处截断,用部分的基函数来近似描述<span class="math inline">\(f(x)\)</span>: <spanclass="math display">\[f(x)\approx S_N(x)=\sum_{k=0}^Nc_kP_k(x)\]</span> 基函数具有一个至多二阶的递推关系: <spanclass="math display">\[P_{k+1}(x)=\alpha_k(x)P_k(x)+\beta_k(x)P_{k-1}(x)\]</span> 现在, 假设我们已经得知<spanclass="math inline">\(\{c_i\}\)</span>, 目的是计算部分和函数<spanclass="math inline">\(S_N(x)\)</span>,这个计算可以通过构造新的函数进行.</p><h3 id="构造新函数">构造新函数</h3><p>我们引入一类新的函数<span class="math inline">\(\{b_i(x)\}\)</span>,并且规定 <span class="math display">\[b_{N+1}=b_{N+2}=0\]</span> 递推关系规定为 <span class="math display">\[b_k(x)=c_k+\alpha_k(x)b_{k+1}(x)+\beta_{k+1}(x)b_{k+2}(x)\]</span></p><h3 id="重新计算部分和函数">重新计算部分和函数</h3><p>我们顺势将部分和函数中的<spanclass="math inline">\(\{c_i\}\)</span>​全部替换, 分裂为三个和: <spanclass="math display">\[S_N(x)=\sum_{k=0}^Nb_k(x)P_k(x)-\sum_{k=0}^N\alpha_k(x)b_{k+1}(x)P_k(x)-\sum_{k=0}^N\beta_{k+1}(x)b_{k+2}(x)P_k(x)\]</span> 基函数<spanclass="math inline">\(\{P_i(x)\}\)</span>同样具有递推关系: <spanclass="math display">\[\begin{aligned}\beta_{k+1}(x)P_k(x)&amp;=P_{k+2}(x)-\alpha_{k+1}(x)P_{k+1}(x)\newline&amp;\Downarrow\newline\sum_{k=0}^N\beta_{k+1}(x)b_{k+2}(x)P_k(x)&amp;=\sum_{k=0}^Nb_{k+2}(x)P_{k+2}(x)-\sum_{k=0}^N\alpha_{k+1}(x)b_{k+2}(x)P_{k+1}(x)\newline&amp;=\sum_{k=2}^Nb_{k}(x)P_{k}(x)-\sum_{k=1}^N\alpha_{k}(x)b_{k+1}(x)P_{k}(x)\end{aligned}\]</span> 代回部分和函数, 得到 <span class="math display">\[S_N(x)=b_0(x)P_0(x)+b_1(x)P_1(x)-\alpha_0(x)b_1(x)P_0(x)\]</span> 我们通常不使用<spanclass="math inline">\(b_0(x)\)</span>(这样就可以少迭代一阶了),而是考虑<spanclass="math inline">\(b_0(x)=c_0+\alpha_0(x)b_1(x)+\beta_1(x)b_2(x)\)</span>,得到 <span class="math display">\[\boxed{S_N(x)=c_0P_0(x)+b_1(x)P_1(x)+\beta_1(x)b_2(x)P_2(x)}\label{eq1}\tag{eq1}\]</span></p><h3 id="方法总结">方法总结</h3><p>所谓 <strong>Clenshaw 逆向迭代法</strong>, 就是已知:</p><ol type="1"><li><p>一个基<span class="math inline">\(\{P_i(x)\}\)</span>​,以及它的递推关系 <span class="math display">\[P_{k+1}(x)=\alpha_k(x)P_k(x)+\beta_k(x)P_{k-1}(x)\]</span></p></li><li><p>一个原函数<span class="math inline">\(f(x)\)</span>,以及它基于某种方案在基<spanclass="math inline">\(\{P_i(x)\}\)</span>​上的有限维近似展开(前文多次称为<strong>部分和函数</strong>)的系数<spanclass="math inline">\(\{c_i\}\)</span> <span class="math display">\[f(x)\approx\sum_{k=0}^Nc_kP_k(x)\]</span></p></li></ol><p>于是构造新函数 <span class="math display">\[b_k(x)=c_k+\alpha_k(x)b_{k+1}(x)+\beta_{k+1}(x)b_{k+2}(x)\newlineb_{N+1}=b_{N+2}=0\]</span> 从而把<spanclass="math inline">\(N\)</span>项的求和化简为少数几项和, 如<spanclass="math inline">\(\eqref{eq1}\)</span>: <spanclass="math display">\[S_N(x)=c_0P_0(x)+b_1(x)P_1(x)+\beta_1(x)b_2(x)P_2(x)\]</span> 因为计算新函数<spanclass="math inline">\(\{b_i(x)\}\)</span>​时, 指标从大到小递推,因此得名为"逆向迭代法".</p><p>经过反向递推, 我们把一个多项的求和式通过递推关系变成了少量几项的求和,这一优点有些时候可以改进求和计算的收敛性和稳定性.</p><h2 id="padé-近似">Padé 近似</h2><p>还有一个常用的近似计算函数的方法是 Padé 近似,也是当作级数展开的补充方法来用. 因为计算很多高阶的级数展开并不容易, Padé近似相当于算了一些阶的级数展开以后来获得更精确结果的方法.</p><p>Padé 近似函数是一个分式函数的形式 <span class="math display">\[R(x)=\frac{\displaystyle\sum_{k=0}^Ma_kx^k}{1+\displaystyle\sum_{k=1}^Nb_kx^k}\]</span> 我们希望它在展开点(例如<spanclass="math inline">\(x=0\)</span>)处与函数相等至<spanclass="math inline">\(M+N\)</span>阶导数: <span class="math display">\[R^{(k)}(0)=c_k\newline(k=0,1,\cdots,M+N)\]</span> 并称它为函数的 <strong><spanclass="math inline">\((M,N)\)</span>阶 Padé 近似</strong>. 其中, <spanclass="math inline">\(c_k=f^{(k)}(0)\)</span>, 或者说<spanclass="math inline">\(f(x)\)</span>的幂级数为<spanclass="math inline">\(\displaystyle\sum_{k=0}^\inftyc_kx^k\)</span>.</p><p>分式函数求导或许比较繁琐, 我们退而求其次, 令<spanclass="math inline">\(R(x)=\displaystyle\sum_{k=0}^\inftyc_kx^k\)</span>, 并把分母乘到等式另一边, 再考虑各阶导数. 特别是<spanclass="math inline">\(M=N\)</span>的情形, 得到 <spanclass="math display">\[\begin{aligned}\sum_{m=1}^Nc_{N-m+k}b_m&amp;=-c_{N+k}\newlinea_k&amp;=\sum_{m=0}^kc_{k-m}b_m\newline(k&amp;=1,\cdots,N)\end{aligned}\label{eq2}\tag{eq2}\]</span> <spanclass="math inline">\(\eqref{eq2}\)</span>上式是一个<spanclass="math inline">\(N\)</span>元线性方程组, 可解出<spanclass="math inline">\(\{b_i\}\)</span>, 再代入<spanclass="math inline">\(\eqref{eq2}\)</span>下式, 计算出<spanclass="math inline">\(\{a_i\}\)</span>. 显然, 我们需要在知道<spanclass="math inline">\(\{c_i\}_{0\sim2N}\)</span>的前提下进行求解.</p>]]></content>
    
    
    <categories>
      
      <category>计算物理</category>
      
      <category>函数数值计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值计算</tag>
      
      <tag>Clenshaw 逆向迭代</tag>
      
      <tag>Padé近似</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数数值计算(03)：Chebyshev 多项式近似</title>
    <link href="/posts/%E5%87%BD%E6%95%B0%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97(03)%EF%BC%9AChebyshev%20%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%BF%91%E4%BC%BC/"/>
    <url>/posts/%E5%87%BD%E6%95%B0%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97(03)%EF%BC%9AChebyshev%20%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%BF%91%E4%BC%BC/</url>
    
    <content type="html"><![CDATA[<p>很多的函数是以级数的形式表达的, 比如 Bessel 函数, Legendre 函数.级数展开在数学上是收敛的, 但是直接按照级数去计算往往并不是最合适的方法,例如</p><p><span class="math display">\[\arctan x=x-\frac{1}{3}x^3+\frac{1}{5}x^5-\cdots\ ,\ x\in[-1,1]\]</span></p><p>利用这个展开式计算<span class="math inline">\(\arctan1\)</span>,即<span class="math inline">\(\displaystyle\frac{\pi}{4}\)</span>,收敛速度慢得离谱. 我们介绍一种新的展开方式.</p><h2 id="chebyshev-多项式及其基本性质">Chebyshev 多项式及其基本性质</h2><p><strong>Chebyshev 多项式</strong> 定义为 <spanclass="math display">\[T_n(x)=\cos(n\arccos x)\ ,\ x\in[-1,1]\]</span></p><p>引入辅助角<span class="math inline">\(x=\cos\phi\)</span>,得到一个正交归一关系</p><p><span class="math display">\[\int_{0}^\piT_i(\cos\phi)T_j(\cos\phi)d\phi=\frac{\pi}{2}(1+\delta_{0i})\delta_{ij}\]</span></p><p>用<span class="math inline">\(x\)</span>表达:</p><p><span class="math display">\[\int_{-1}^1\frac{T_i(x)T_j(x)}{\sqrt{1-x^2}}dx=\begin{aligned}\begin{cases}\displaystyle0&amp;\text{if }i\ne j\\\displaystyle\frac{\pi}{2}&amp;\text{if }i=j\ne0\\\displaystyle\pi&amp;\text{if }i=j=0\end{cases}\end{aligned}\]</span></p><h2 id="零点处的正交归一关系">零点处的正交归一关系</h2><p>在<spanclass="math inline">\([-1,1]\)</span>上的正交归一关系提示我们将其用作函数展开的基:<span class="math display">\[f(x)=\frac{c_0}{2}+\sum_{k=1}^{N-1}c_kT_k(x)\]</span></p><p>如果希望这个式子在<spanclass="math inline">\(T_N(x)\)</span>的零点处严格成立, 则</p><p><span class="math display">\[f\left[\cos((k+\frac{1}{2})\pi/N)\right]=\frac{c_0}{2}+\sum_{m=1}^{N-1}c_m\cos((k+\frac{1}{2})m\pi/N)\]</span> 我们先考虑两个特别的求和式.</p><h3 id="displaystylesum_k0n-1coskfrac12theta">1. <spanclass="math inline">\(\displaystyle\sum_{k=0}^{N-1}\cos((k+\frac{1}{2})\theta)\)</span></h3><p>这个式子没啥好说的, 凑一个因子<spanclass="math inline">\(\sin(\theta/2)\)</span>, 得 <spanclass="math display">\[\begin{aligned}\sum_{k=0}^{N-1}\cos((k+\frac{1}{2})\theta)&amp;=\frac{1}{\sin\theta/2}\sum_{k=0}^{N-1}\cos((k+\frac{1}{2})\theta)\sin\theta/2\newline&amp;=\sum_{k=0}^{N-1}\frac{\sin(k+1)\theta-\sin k\theta}{2\sin\theta/2}\newline&amp;=\frac{\sin(N\theta)}{2\sin\theta/2}\end{aligned}\]</span></p><h3 id="displaystylesum_k0n-1coskfrac12mpincoskfrac12mpin">2. <spanclass="math inline">\(\displaystyle\sum_{k=0}^{N-1}\cos((k+\frac{1}{2})m\pi/N)\cos((k+\frac{1}{2})m&#39;\pi/N)\)</span></h3><p>同样进行积化和差 <span class="math display">\[\begin{aligned}\text{原式}&amp;=\frac{1}{2}\sum_{k=0}^{N-1}\cos((k+\frac{1}{2})(m+m&#39;)\pi/N)+\frac{1}{2}\sum_{k=0}^{N-1}\cos((k+\frac{1}{2})(m-m&#39;)\pi/N)\newline&amp;=\frac{\sin(m+m&#39;)\pi}{4\displaystyle\sin\frac{m+m&#39;}{2N}\pi}+\frac{\sin(m-m&#39;)\pi}{4\displaystyle\sin\frac{m-m&#39;}{2N}\pi}\end{aligned}\]</span> 简单地讨论<span class="math inline">\(m\)</span>和<spanclass="math inline">\(m&#39;\)</span>的取值, 得到 <spanclass="math display">\[\sum_{k=0}^{N-1}\cos((k+\frac{1}{2})m\pi/N)\cos((k+\frac{1}{2})m&#39;\pi/N)=\begin{aligned}\begin{cases}\displaystyle0&amp;\text{if }m\ne m&#39;\newline\displaystyle\frac{N}{2}&amp;\text{if }m=m&#39;\ne0\newline\displaystyleN&amp;\text{if }m=m&#39;=0\end{cases}\end{aligned}\]</span> 记作<span class="math inline">\(T_{mm&#39;}\)</span>.</p><h2 id="chebyshev-展开">Chebyshev 展开</h2><p>回到系数满足的条件 <span class="math display">\[f\left[\cos((k+\frac{1}{2})\pi/N)\right]=\frac{c_0}{2}+\sum_{m=1}^{N-1}c_m\cos((k+\frac{1}{2})m\pi/N)\]</span> 两边同乘以<spanclass="math inline">\(\displaystyle\cos((k+\frac{1}{2})m&#39;\pi/N)\)</span>并对<spanclass="math inline">\(k\)</span>​​求和, 得到 <span class="math display">\[\sum_{k=0}^{N-1}f\left[\cos((k+\frac{1}{2})\pi/N)\right]\cos((k+\frac{1}{2})m&#39;\pi/N)=\frac{c_0}{2}T_{0m&#39;}+\sum_{m=1}^{N-1}c_mT_{mm&#39;}=\frac{N}{2}c_0\delta_{0m&#39;}+\frac{N}{2}c_{m}\delta_{mm&#39;}\]</span> 取<span class="math inline">\(m&#39;\)</span>为<spanclass="math inline">\([0,N-1]\)</span>上不同的整数, 得到 <spanclass="math display">\[\boxed{c_m=\frac{2}{N}\sum_{k=0}^{N-1}f\left[\cos((k+\frac{1}{2})\pi/N)\right]\cos((k+\frac{1}{2})m\pi/N)}\]</span> 这就是 Chebyshev 展开的系数计算公式.</p><p>这里给出 Chebyshev 展开在 Runge 现象中的应用, 它的各个基之间是正交的,而幂级数的基之间具有很大的overlap, 所以前者才能解决所谓的 Runge现象.</p><figure><img src="../img/chebyshev_expansion_of_runge_function.png"alt="Runge 函数的 Chebyshev 展开" /><figcaption aria-hidden="true">Runge 函数的 Chebyshev 展开</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>计算物理</category>
      
      <category>函数数值计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值计算</tag>
      
      <tag>Chebyshev 多项式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数数值计算(02)：有理函数插值法, 样条函数插值法</title>
    <link href="/posts/%E5%87%BD%E6%95%B0%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97(02)%EF%BC%9A%E6%9C%89%E7%90%86%E5%87%BD%E6%95%B0%E6%8F%92%E5%80%BC%E6%B3%95,%20%E6%A0%B7%E6%9D%A1%E5%87%BD%E6%95%B0%E6%8F%92%E5%80%BC%E6%B3%95/"/>
    <url>/posts/%E5%87%BD%E6%95%B0%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97(02)%EF%BC%9A%E6%9C%89%E7%90%86%E5%87%BD%E6%95%B0%E6%8F%92%E5%80%BC%E6%B3%95,%20%E6%A0%B7%E6%9D%A1%E5%87%BD%E6%95%B0%E6%8F%92%E5%80%BC%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="有理函数插值法">有理函数插值法</h2><p>上一节提到, 当函数在某个区间内的变化行为比较剧烈时,多项式内插会出现剧烈震荡的行为.这时候利用有理函数进行内插可能会更加合适一些,它的构造可以采用一个分式的形式: <span class="math display">\[\Phi_{n,n}(x)=\frac{P_n(x)}{Q_n(x)}\]</span></p><p>其中<span class="math inline">\(P_n\)</span>和<spanclass="math inline">\(Q_n\)</span>都是<spanclass="math inline">\(n\)</span>阶多项式, 并且它们互素.</p><p>想要完全确定两者, 需要<spanclass="math inline">\(2n+2\)</span>个支撑点, 但是在<spanclass="math inline">\(\Phi_{n,n}\)</span>中, 两者相除,实际上造成了一个自由的公倍数, 也就是只需要<spanclass="math inline">\(2n+1\)</span>个支撑点, 记为<spanclass="math inline">\((x_0,y_0),(x_1,y_1),\cdots,(x_{2n},y_{2n})\)</span>.作为内插函数, <spanclass="math inline">\(\Phi_{n,n}\)</span>需要通过所有的支撑点,可以写成如下形式:</p><p><span class="math display">\[\Phi_{n,n}(x)=\phi_0(x_0)+\frac{x-x_0}{\Phi_{n-1,n-1}(x)}\]</span></p><p>其中, <spanclass="math inline">\(\phi_0(x_0)=y_0\)</span>以通过支撑点<spanclass="math inline">\(0\)</span>. 分母又可以写为:</p><p><span class="math display">\[\Phi_{n-1,n-1}(x)=\phi_1(x_0,x_1)+\frac{x-x_1}{\Phi_{n-2,n-2}(x)}\]</span></p><p>这样, <spanclass="math inline">\(\phi_1(x_0,x_1)\)</span>必须满足</p><p><span class="math display">\[\phi_0(x_0)+\frac{x_1-x_0}{\phi_1(x_0,x_1)}=y_1\Rightarrow\phi_1=\frac{x_1-x_0}{y_1-\phi_0(x_0)}\]</span></p><p>为了形式对称性, 把<span class="math inline">\(y_1\)</span>改写为<spanclass="math inline">\(\phi_0(x_1)\)</span>, 则</p><p><span class="math display">\[\phi_1(x_0,x_1)=\frac{x_1-x_0}{\phi_0(x_1)-\phi_0(x_0)}\]</span></p><p>对于更一般的情况, 我们不妨倒转递推方向</p><p><span class="math display">\[\Phi_{n-j-1,n-j-1}(x)=\frac{x-x_j}{\Phi_{n-j,n-j}(x)-\phi_j(x_0,x_1,\cdots,x_j)}\]</span></p><p>令<span class="math inline">\(x=x_{j+1}\)</span>, 立即得到</p><p><span class="math display">\[\phi_{j+1}(x_0, x_1, \cdots,x_{j+1})=\frac{x_{j+1}-x_{j}}{\phi_j(x_0,x_1,\cdots,x_{j-1},x_{j+1})-\phi_j(x_0,x_1,\cdots,x_{j-1},x_{j}}\]</span></p><p>它给出了各阶<span class="math inline">\(\phi\)</span>函数的递推关系.而<span class="math inline">\(\Phi_{n,n}\)</span>写成连分数的形式:</p><p><span class="math display">\[\Phi_{n,n}(x)=\phi_0(x_0)+\frac{x-x_0}{\phi_1(x_0,x_1)+\displaystyle\frac{x-x_1}{\phi_2(x_0,x_1,x_2)+\displaystyle\frac{x-x_2}{\ddots+\displaystyle\frac{x-x_{2n-1}}{\phi_{2n}(x_0,\cdots,x_{2n})}}}}\]</span></p><p>如果我们在一个单调的区间插值, 那么上述构造不会发散. 特别是对于 Runge函数这种有理分式, 把<span class="math inline">\(x^2\)</span>看作自变量,只需构造<spanclass="math inline">\(\Phi_{1,1}\)</span>形式的有理内插函数,取三个支撑点就能完成内插, 并且和原函数一模一样, 所谓的 Runge现象自然也就不再出现.</p><h2 id="样条函数插值法">样条函数插值法</h2><p>样条函数的基本思想是在每两个支撑点之间用一段多项式函数来表示,最常用的是三次样条函数, 这里也仅介绍三次样条函数.</p><h3 id="基本准备">基本准备</h3><p>在区间<span class="math inline">\([a,b]\)</span>上包括两端一共有<spanclass="math inline">\(n+1\)</span>个支撑点: <spanclass="math inline">\((x_0,y_0),(x_1,y_1),\cdots,(x_n,y_n)\)</span>.样条函数记作<span class="math inline">\(S(x), x\in[a,b]\)</span>.</p><p>每个子区间都具有一个三次多项式作为样条函数, 也就是<spanclass="math inline">\(4n\)</span>个待定参数. 可用的方程又有多少个呢?</p><ul><li><p>每个内部支撑点限制左右两个子区间的函数值, 给出两个方程,而外部两个支撑点各自只给出一个限制, 一共<spanclass="math inline">\(2n\)</span>个方程;</p></li><li><p>每个内部支撑点限制左右导函数相等, 一共<spanclass="math inline">\(n-1\)</span>个方程;</p></li><li><p>每个内部支撑点限制左右二阶导数相等, 一共<spanclass="math inline">\(n-1\)</span>个方程.</p></li></ul><p>我们现在有<span class="math inline">\(4n-2\)</span>个限制条件可用,得到的样条函数具有<span class="math inline">\(2\)</span>个自由度.自由度的来源无非是端点处边界条件不够完备, 我们只知道边界处的函数值,不知道边界处的导函数或者是二阶导函数的取值,因此需要再引入两个独立的约束方程,具体形式可以研究问题的数学或物理性质得到.</p><h3 id="计算参数">计算参数</h3><p>定义二阶导数在各个支撑点处的取值为 <strong>矩</strong>:</p><p><span class="math display">\[M_j=S&#39;&#39;(x_j)\ ,\ j =0,1,\cdots,n\]</span></p><p>三次多项式的二阶导数是一次函数, 因而对于每一段<spanclass="math inline">\([x_j,x_{j+1}], \ j=0,1,\cdots,n-1\)</span>,不难写出<span class="math inline">\(S&#39;&#39;\)</span>的表达式</p><p><span class="math display">\[S&#39;&#39;(x)=\frac{M_j(x_{j+1}-x)+M_{j+1}(x-x_j)}{x_{j+1}-x_j}\]</span></p><p>连续两次积分, 得到</p><p><span class="math display">\[S(x)=\frac{M_j(x_{j+1}-x)^3}{6(x_{j+1}-x_j)}+\frac{M_{j+1}(x-x_j)^3}{6(x_{j+1}-x_j)}+A_j(x-x_j)+B_j\, x\in[x_j,x_{j+1}]\]</span></p><p>这里<span class="math inline">\(A, B, M\)</span>一共是<spanclass="math inline">\(3n+1\)</span>个参数<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="为什么不是 $4n$ 个? 因为提前使用了二阶导连续的条件, 消去了 $n-1$ 个系数">[1]</span></a></sup>,考虑<span class="math inline">\(x_j\)</span>处函数值连续, 有</p><p><span class="math display">\[\frac{M_j(x_{j+1}-x_j)^2}{6}+B_j=\frac{M_j(x_{j}-x_{j-1})^2}{6}+A_{j-1}(x_j-x_{j-1})+B_{j-1}=y_j\]</span></p><p>得到</p><p><span class="math display">\[\boxed{\begin{aligned}B_j&amp;=y_j-\frac{M_j(x_{j+1}-x_j)^2}{6}\newlineA_j&amp;=\frac{y_{j+1}-y_j}{x_{j+1}-x_j}-\frac{M_{j+1}-M_j}{6}(x_{j+1}-x_j)\end{aligned}}\]</span></p><p>现在只剩<span class="math inline">\(n+1\)</span>个待定参数了, 同样地,内部限制条件只有<spanclass="math inline">\(n-1\)</span>个支撑点处的导数连续.</p><p><span class="math display">\[S&#39;(x)=-\frac{M_j(x_{j+1}-x)^2}{2(x_{j+1}-x_j)}+\frac{M_{j+1}(x-x_j)^2}{2(x_{j+1}-x_j)}+A_j\, x\in[x_j,x_{j+1}]\]</span></p><p>考虑<span class="math inline">\(x_j\)</span>处的导函数连续, 有</p><p><span class="math display">\[-\frac{M_j(x_{j+1}-x_j)}{2}+A_j=\frac{M_j(x_j-x_{j-1})}{2}+A_{j-1}\]</span></p><p>代入整理, 最终得到</p><p><span class="math display">\[\boxed{    \frac{x_{j+1}-x_j}{6}M_{j+1}+\frac{x_{j+1}-x_j}{3}M_j+\frac{x_j-x_{j-1}}{6}M_{j-1}=\frac{y_{j+1}-y_j}{x_{j+1}-x_j}-\frac{y_j-y_{j-1}}{x_j-x_{j-1}}}\]</span></p><p>这些式子给出全部的支撑点的约束方程,只要再给边界上<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="事实上可以是任两个无关且独立于之前所有约束方程的方程即可, 但实际问题中常常更容易得知边界处的条件">[2]</span></a></sup>引入两个独立约束即可.</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>为什么不是 <spanclass="math inline">(4n)</span> 个? 因为提前使用了二阶导连续的条件,消去了 <span class="math inline">(n-1)</span> 个系数<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>事实上可以是任两个无关且独立于之前所有约束方程的方程即可,但实际问题中常常更容易得知边界处的条件<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算物理</category>
      
      <category>函数数值计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值计算</tag>
      
      <tag>插值法</tag>
      
      <tag>有理函数插值</tag>
      
      <tag>样条函数插值法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数数值计算(01)：多项式插值</title>
    <link href="/posts/%E5%87%BD%E6%95%B0%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97(01)%EF%BC%9A%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8F%92%E5%80%BC/"/>
    <url>/posts/%E5%87%BD%E6%95%B0%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97(01)%EF%BC%9A%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8F%92%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="lagrange-插值法">Lagrange 插值法</h2><p>考虑区间<spanclass="math inline">\([x_0,x_n]\)</span>上的n次多项式内插</p><p><span class="math display">\[P_n(x)=a_0+a_1x+\cdots+a_nx^n\]</span></p><p>已知的点为<spanclass="math inline">\((x_0,y_0),(x_1,y_1),\cdots,(x_n,y_n)\)</span>.内插要求多项式的曲线通过这些点:</p><p><span class="math display">\[P_n(x_j)=y_j\ ,\ j = 0, 1, \cdots, n\]</span></p><p>为了求出这个问题的一般解, 我们将<spanclass="math inline">\(P_n\)</span>写成多项式的和:</p><p><span class="math display">\[P_n(x) = \sum_jp_{nj}(x)\]</span></p><p>其中, <spanclass="math inline">\(p_{nj}(x_k)=y_j\delta_{jk}\)</span>.</p><p>由于<span class="math inline">\(p_{nj}\)</span>具有<spanclass="math inline">\(n\)</span>个零点, 故它必然能写成</p><p><span class="math display">\[p_{nj}(x)=a_{nj}\prod_{m=0且m\ne j}^{n}(x-x_m)\]</span></p><p><span class="math inline">\(a_{nj}\)</span>只是系数, 因为<spanclass="math inline">\(n\)</span>个零点已经构成了<spanclass="math inline">\(n\)</span>次多项式. 代入<spanclass="math inline">\((x_j, y_j)\)</span>得到</p><p><span class="math display">\[a_{nj}=\frac{y_j}{\prod_{m=0且m\ne j}^{n}(x_j-x_m)}\]</span></p><p>最终我们得到</p><p><span class="math display">\[\boxed{P_n(x)=\sum_jy_jL_j(x)}\newline \ \newline\text{其中, } \boxed{L_j(x)=\prod_{m\ne j}\frac{x-x_m}{x_j-x_m}}\]</span></p><p>这个结果被称作 <strong>Larange多项式</strong>, 也称<strong>Lagrange内插公式</strong>.</p><h2 id="newton-插值法">Newton 插值法</h2><p>Newton 的多项式内插法是一种递推方法:</p><p><span class="math display">\[N(x)=\sum_{j=0}^{n}a_jn_j(x)\newline\text{其中, }n_j(x)=\prod_{k=0}^{j-1}(x-x_k),\ n_0(x)=1\]</span></p><p>好处是如果增加一个支撑点, 不破坏之前所有支撑条件, 仅需计算<spanclass="math inline">\(a_{n+1}\)</span>和<spanclass="math inline">\(n_{n+1}(x)\)</span>:</p><p><span class="math display">\[a_0+\sum_{j=1}^{n+1}a_j\cdot\prod_{k=0}^{j-1}(x_{n+1}-x_k) = y_{n+1}\]</span></p><p>如何求解系数呢? 上式相当于一个方程组</p><p><span class="math display">\[\begin{pmatrix}1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0\\1 &amp; x_1-x_0 &amp; 0 &amp; \cdots &amp; 0\\1 &amp; x_2-x_0 &amp; (x_2-x_0)(x_2-x_1) &amp; \cdots &amp; 0\\\cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; 0\\1 &amp; x_n-x_0 &amp; (x_n-x_0)(x_n-x_1) &amp; \cdots &amp;\prod_{j=0}^{n-1}(x_n-x_j)\end{pmatrix}\begin{pmatrix}a_0 \\ a_1 \\ a_2 \\ \cdots \\ a_n\end{pmatrix}=\begin{pmatrix}y_0 \\ y_1 \\ y_2 \\ \cdots \\ y_n\end{pmatrix}\]</span></p><p>解这个下三角矩阵描述的线性方程组问题, 即得各项系数.</p><h2 id="neville-迭代法">Neville 迭代法</h2><p>先构造<span class="math inline">\(n+1\)</span>个常数函数:</p><p><span class="math display">\[Q_i(x)=y_i\]</span></p><p>按指标大小顺序排列<span class="math inline">\(Q_i\)</span>,再用每对相邻的函数构造更高阶函数, 并且用双下标做记号:</p><p><span class="math display">\[P_{ij}=\frac{(x-x_i)Q_j-(x-x_j)Q_i}{x_j-x_i}\]</span></p><p>现在得到<span class="math inline">\(n\)</span>个双下标的一次函数,按第一指标顺序排列, 再用相邻的函数对构造二次函数:</p><p><span class="math display">\[P_{ijk}=\frac{(x-x_i)P_{jk}-(x-x_k)P_{ij}}{x_k-x_i}\]</span></p><p>至于下标, 略去重复数字, 为三下标. 如法炮制, 最终得到单个<spanclass="math inline">\(n\)</span>次函数.</p><h2 id="runge-现象">Runge 现象</h2><p>一般情况下, 多项式的次数越多, 需要的数据就越多, 而预测也就越准确.但也存在插值次数越高, 插值结果越偏离原函数的现象,特别常发生在区间的端点处, 称为 <strong>Runge现象</strong><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="关于 Runge 现象的定性介绍, 可以参见[它的维基百科](https://zh.wikipedia.org/wiki/龙格现象).">[1]</span></a></sup>.</p><p>特别地, 考虑函数</p><p><span class="math display">\[f(x)=\frac{1}{1+25x^2}\]</span></p><p>称为 <strong>Runge 函数</strong>. 在区间<spanclass="math inline">\([-1, 1]\)</span>上, 以<spanclass="math inline">\(\frac{2}{n}\)</span>为步长选取支撑点进行 Lagrange插值, 得到的结果如下所示:</p><figure><img src="../img/runge&#39;s_phenomenon.png" alt="Runge 现象" /><figcaption aria-hidden="true">Runge 现象</figcaption></figure><p>造成这种现象的主要原因是，拉格朗日插值使用的函数基组<spanclass="math inline">\(1,𝑥,𝑥^2,\cdots\)</span>​并不是正交基,插值结果十分病态, 可以考虑对基函数进行 Schmidt 正交化,但更方便的方案是选取既正交又简单的非多项式基,或者干脆不使用这种内插方案, 这是下一节将要讨论到的.</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>关于 Runge 现象的定性介绍,可以参见<ahref="https://zh.wikipedia.org/wiki/龙格现象">它的维基百科</a>.<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>计算物理</category>
      
      <category>函数数值计算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数值计算</tag>
      
      <tag>插值法</tag>
      
      <tag>多项式插值</tag>
      
      <tag>Lagrange 插值法</tag>
      
      <tag>Newton 插值法</tag>
      
      <tag>Neville 迭代法</tag>
      
      <tag>Runge 现象</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
